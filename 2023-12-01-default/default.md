# Дефолтная работа чужого кода

## 1. Выводы по изучению материала
Если копнуть глубже, то проблема с недокументированным поведением
чужого (да и своего тоже) кода лежит в избытке информации/возможностей.
Именно в избытке.
Может показаться, что проблема в том, что нам недостаточно знаний о работе кода,
но она в том, что эти знания нам вообще понадобились.

Первый пример: функция возвращает массив/список/кортеж - любую упорядоченную
структуру данных, а порядок нам не нужен.
Тогда порядок элементов в массиве - это избыточная информация.
Её быть не должно, лучше использовать множество, но нет, при изучении
языков программирования акцент делается на массивы/списки, а множества
задвигаются куда-то как какая-то экзотика.

Второй пример: метод класса возвращает мутабельную структуру данных,
и через неё есть доступ к внутренностям класса.
Это избыточные возможности.
Программы на Python этому очень подвержены, потому что синтаксически
более удобно и компактно записывается создание мутабельных структур данных,
чем иммутабельных (особенно `{a}` vs `frozenset({a})`).
Для словарей (`dict`) вообще нет иммутабельной структуры данных.

В идеале лучше стараться не давать лишнюю информацию и лишние возможности.
Тогда не будет и соблазна как-то это интерпретировать и использовать.


## 2. Примеры надежд на дефолтную работу чужого кода

### 2.1 numpy.lexsort
Сначала сортировка происходит по последнему ключу,
потом по предпоследнему и т.д.
Я думал, что наоборот.
Это же лексикографическая сортировка, при сортировке текста левые
символы важнее правых.
Но эту функцию, видимо, писали арабы.

Я целый час потратил, пытаясь понять что в программе не так,
а потом в документации к этой функции обнаружил соответствующую пометку.


### 2.2 Собственные векторы в LAPACK
Это фортрановская библиотека для работы с матрицами, и собственные векторы
возвращаются как двумерный массив, упакованный по столбцам.
То есть, сначала в памяти лежит первый столбец, потом второй и т.д.
При этом в математике принято матрицу читать построчно,
и в C-подобных языках двумерные массивы тоже хранятся построчно.
Поэтому я и рассчитывал, что векторы лежат построчно,
и это привело к ошибке в вычислениях.

Снова проблема была в том, что невнимательно изучил документацию.


### 2.3 SDLang и научная нотация
Пытался использовать SDLang (Simple Declarative Language) для обмена данными
в своих расчётных программах.
Надеялся, что раз там есть даже матрицы, то с числами с плавающей точкой
он точно справится, но нет.
Оказывается, автор языка вовсе не имел в виду поддержку такой "экзотики",
как числа в научной нотации: `9.1e-31`.
Чтобы парсер мог их прочитать и не выдавал ошибку,
нужно было писать что-то типа `0.0000000000000000000000000000091`.

То что стандарт записи чисел с плавающей точкой поддерживается не полностью
в документации не было указано.
Когда я отправил багрепорт, то автор добавил в репозиторий со
**спецификацией** языка feature-request для поддержки научной нотации
и пометил его как `spec-v2`.
Так я понял, что ждать второй версии спецификации нужно лет 5-10
и першёл к другим инструментам.
Сейчас прошло 7 лет, SDLang по-прежнему не поддерживает научную нотацию
и по-прежнему позиционируется как перспективная замена всего и вся.
Ну... ОК.


### Выводы
Спецификацию функций нужно читать так же внимательно, как кредитный договор :)
Там тоже могут быть условия со звёздочкой про контринтуитивное (lexsort)
или непривычное (Fortran vs C) поведение функций.

Никаких экспериментальных фич (языков) в работе!


## 3. Исключение нежелательной формы обработки результата

### 3.1 Данные о направлении распространения волны
Есть данные о распространении волны в среде в виде многомерного массива.
Одна из осей массива "помечена" как направление распространения волны
и имеет размер 2: 0 для прямого и 1 для обратного направления...
Или наоборот?

Вот чтобы такого вопроса не возникало,
теперь буду использовать другой тип данных.

Раньше было примерно так:
```Python
class WaveAxisKind(Enum):
    DIR = auto()
    SOL = auto()
    COMP = auto()
    ...

DIR = WaveAxisKind.DIR
SOL = WaveAxisKind.SOL
COMP = WaveAxisKind.COMP
...

class WaveSolutionTensor(SquareMatrixTensor):
    ...
    # Код, превращающий DIR/SOL/COMP в столбцы и строки для SquareMatrixTensor
    ...

...
waves = WaveSolutionTensor(array, dir_axis(DIR), ...)
...
... waves.unwrap(dir_axis, ...)[0, ...]
... waves.unwrap(dir_axis, ...)[1, ...]
```

Теперь так
```Python
SOL = MatrixAxisKind.COL   # WaveAxisKind больше не нужен!!!
COMP = MatrixAxisKind.ROW
...

class WaveSolutionTensor(SquareMatrixTensor, BasisTensor):
    ...
    # Получаем строки и столбцы автоматически благодаря SquareMatrixTensor
    ...

class WaveDirBasis(Basis):
    LEFT: Literal[0, 1] = 0
    RIGHT: Literal[0, 1] = 1
    
    @property
    def size(self) -> int:
        return 2

LEFT = WaveDirBasis.LEFT
RIGHT = WaveDirBasis.RIGHT
...
waves = WaveSolutionTensor(array, dir_axis(SOL, basis=dir_basis), ...)
...
... waves.unwrap(dir_axis, ...)[LEFT, ...]   # лево и право
... waves.unwrap(dir_axis, ...)[RIGHT, ...]  # вместо магических 0 и 1
```

Мы не просто улучшили возвращаемый тип данных, добавив базис-направление.
Есть ещё пара преимуществ.

В предметной области есть разделение на решения `SOL` и компоненты `COMP`.
Решения сортируются по направлению `DIR` и всему остальному,
то есть направление волны находится на уровень ниже
в иерархии классов осей массива.
В коде `DIR` и `SOL` были как-бы на равных, что создавало путаницу.
Теперь путаницы нет, потому что нет `DIR`.
Вместо него теперь `SOL` + `basis=dir_basis`.

Раньше нужно было готовить параметры осей `DIR`/`SOL`/`COMP` для работы с ними
класса `SquareMatrixTensor`, который оперирует понятиями `COL`/`ROW`.
Сложности возникали из-за разделения `DIR`/`SOL`.
Теперь всё просто: `SOL=COL`, `COMP=ROW`,
больше не нужны дополнительные типы данных
и лишний этап обработки параметров осей.


### 3.2


### 3.3

