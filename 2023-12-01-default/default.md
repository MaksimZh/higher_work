# Дефолтная работа чужого кода

## 1. Выводы по изучению материала
Если копнуть глубже, то проблема с недокументированным поведением
чужого (да и своего тоже) кода лежит в избытке информации/возможностей.
Именно в избытке.
Может показаться, что проблема в том, что нам недостаточно знаний о работе кода,
но она в том, что эти знания нам вообще понадобились.

Первый пример: функция возвращает массив/список/кортеж - любую упорядоченную
структуру данных, а порядок нам не нужен.
Тогда порядок элементов в массиве - это избыточная информация.
Её быть не должно, лучше использовать множество, но нет, при изучении
языков программирования акцент делается на массивы/списки, а множества
задвигаются куда-то как какая-то экзотика.

Второй пример: метод класса возвращает мутабельную структуру данных,
и через неё есть доступ к внутренностям класса.
Это избыточные возможности.
Программы на Python этому очень подвержены, потому что синтаксически
более удобно и компактно записывается создание мутабельных структур данных,
чем иммутабельных (особенно `{a}` vs `frozenset({a})`).
Для словарей (`dict`) вообще нет иммутабельной структуры данных.

В идеале лучше стараться не давать лишнюю информацию и лишние возможности.
Тогда не будет и соблазна как-то это интерпретировать и использовать.


## 2. Примеры надежд на дефолтную работу чужого кода

### 2.1 numpy.lexsort
Сначала сортировка происходит по последнему ключу,
потом по предпоследнему и т.д.
Я думал, что наоборот.
Это же лексикографическая сортировка, при сортировке текста левые
символы важнее правых.
Но эту функцию, видимо, писали арабы.

Я целый час потратил, пытаясь понять что в программе не так,
а потом в документации к этой функции обнаружил соответствующую пометку.


### 2.2 Собственные векторы в LAPACK
Это фортрановская библиотека для работы с матрицами, и собственные векторы
возвращаются как двумерный массив, упакованный по столбцам.
То есть, сначала в памяти лежит первый столбец, потом второй и т.д.
При этом в математике принято матрицу читать построчно,
и в C-подобных языках двумерные массивы тоже хранятся построчно.
Поэтому я и рассчитывал, что векторы лежат построчно,
и это привело к ошибке в вычислениях.

Снова проблема была в том, что невнимательно изучил документацию.


### 2.3 SDLang и научная нотация
Пытался использовать SDLang (Simple Declarative Language) для обмена данными
в своих расчётных программах.
Надеялся, что раз там есть даже матрицы, то с числами с плавающей точкой
он точно справится, но нет.
Оказывается, автор языка вовсе не имел в виду поддержку такой "экзотики",
как числа в научной нотации: `9.1e-31`.
Чтобы парсер мог их прочитать и не выдавал ошибку,
нужно было писать что-то типа `0.0000000000000000000000000000091`.

То что стандарт записи чисел с плавающей точкой поддерживается не полностью
в документации не было указано.
Когда я отправил багрепорт, то автор добавил в репозиторий со
**спецификацией** языка feature-request для поддержки научной нотации
и пометил его как `spec-v2`.
Так я понял, что ждать второй версии спецификации нужно лет 5-10
и першёл к другим инструментам.
Сейчас прошло 7 лет, SDLang по-прежнему не поддерживает научную нотацию
и по-прежнему позиционируется как перспективная замена всего и вся.
Ну... ОК.


### Выводы
Спецификацию функций нужно читать так же внимательно, как кредитный договор :)
Там тоже могут быть условия со звёздочкой про контринтуитивное (lexsort)
или непривычное (Fortran vs C) поведение функций.

Никаких экспериментальных фич (языков) в работе!


## 3. Исключение нежелательной формы обработки результата

