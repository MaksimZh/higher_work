# Дефолтная работа чужого кода

## 1. Выводы по изучению материала
Если копнуть глубже, то проблема с недокументированным поведением
чужого (да и своего тоже) кода лежит в избытке информации/возможностей.
Именно в избытке.
Может показаться, что проблема в том, что нам недостаточно знаний о работе кода,
но она в том, что эти знания нам вообще понадобились.

Первый пример: функция возвращает массив/список/кортеж - любую упорядоченную
структуру данных, а порядок нам не нужен.
Тогда порядок элементов в массиве - это избыточная информация.
Её быть не должно, лучше использовать множество, но нет, при изучении
языков программирования акцент делается на массивы/списки, а множества
задвигаются куда-то как какая-то экзотика.

Второй пример: метод класса возвращает мутабельную структуру данных,
и через неё есть доступ к внутренностям класса.
Это избыточные возможности.
Программы на Python этому очень подвержены, потому что синтаксически
более удобно и компактно записывается создание мутабельных структур данных,
чем иммутабельных (особенно `{a}` vs `frozenset({a})`).
Для словарей (`dict`) вообще нет иммутабельной структуры данных.

В идеале лучше стараться не давать лишнюю информацию и лишние возможности.
Тогда не будет и соблазна как-то это интерпретировать и использовать.


## 2. Примеры надежд на дефолтную работу чужого кода

### 2.1 numpy.lexsort
Сначала сортировка происходит по последнему ключу,
потом по предпоследнему и т.д.
Я думал, что наоборот.
Это же лексикографическая сортировка, при сортировке текста левые
символы важнее правых.
Но эту функцию, видимо, писали арабы.

Я целый час потратил, пытаясь понять что в программе не так,
а потом в документации к этой функции обнаружил соответствующую пометку.


### 2.2 Собственные векторы в LAPACK
Это фортрановская библиотека для работы с матрицами, и собственные векторы
возвращаются как двумерный массив, упакованный по столбцам.
То есть, сначала в памяти лежит первый столбец, потом второй и т.д.
При этом в математике принято матрицу читать построчно,
и в C-подобных языках двумерные массивы тоже хранятся построчно.
Поэтому я и рассчитывал, что векторы лежат построчно,
и это привело к ошибке в вычислениях.

Снова проблема была в том, что невнимательно изучил документацию.


### 2.3 SDLang и научная нотация
Пытался использовать SDLang (Simple Declarative Language) для обмена данными
в своих расчётных программах.
Надеялся, что раз там есть даже матрицы, то с числами с плавающей точкой
он точно справится, но нет.
Оказывается, автор языка вовсе не имел в виду поддержку такой "экзотики",
как числа в научной нотации: `9.1e-31`.
Чтобы парсер мог их прочитать и не выдавал ошибку,
нужно было писать что-то типа `0.0000000000000000000000000000091`.

То что стандарт записи чисел с плавающей точкой поддерживается не полностью
в документации не было указано.
Когда я отправил багрепорт, то автор добавил в репозиторий со
**спецификацией** языка feature-request для поддержки научной нотации
и пометил его как `spec-v2`.
Так я понял, что ждать второй версии спецификации нужно лет 5-10
и першёл к другим инструментам.
Сейчас прошло 7 лет, SDLang по-прежнему не поддерживает научную нотацию
и по-прежнему позиционируется как перспективная замена всего и вся.
Ну... ОК.


### Выводы
Спецификацию функций нужно читать так же внимательно, как кредитный договор :)
Там тоже могут быть условия со звёздочкой про контринтуитивное (lexsort)
или непривычное (Fortran vs C) поведение функций.

Никаких экспериментальных фич (языков) в работе!


## 3. Исключение нежелательной формы обработки результата

### 3.1 Данные о направлении распространения волны
Есть функция, которая возвращает данные о распространении волны в среде
в виде многомерного массива.
Одна из осей массива "помечена" как направление распространения волны
и имеет размер 2: 0 для прямого и 1 для обратного направления...
Или наоборот?

Вот чтобы такого вопроса не возникало,
теперь буду использовать другой тип данных.

Раньше было примерно так:
```Python
class WaveAxisKind(Enum):
    DIR = auto()
    SOL = auto()
    COMP = auto()
    ...

DIR = WaveAxisKind.DIR
SOL = WaveAxisKind.SOL
COMP = WaveAxisKind.COMP
...

class WaveSolutionTensor(SquareMatrixTensor):
    ...
    # Код, превращающий DIR/SOL/COMP в столбцы и строки для SquareMatrixTensor
    ...

...
waves = WaveSolutionTensor(array, dir_axis(DIR), ...)
...
... waves.unwrap(dir_axis, ...)[0, ...]
... waves.unwrap(dir_axis, ...)[1, ...]
```

Теперь так
```Python
SOL = MatrixAxisKind.COL   # WaveAxisKind больше не нужен!!!
COMP = MatrixAxisKind.ROW
...

class WaveSolutionTensor(SquareMatrixTensor, BasisTensor):
    ...
    # Получаем строки и столбцы автоматически благодаря SquareMatrixTensor
    ...

class WaveDirBasis(Basis):
    LEFT: Literal[0, 1] = 0
    RIGHT: Literal[0, 1] = 1
    
    @property
    def size(self) -> int:
        return 2

LEFT = WaveDirBasis.LEFT
RIGHT = WaveDirBasis.RIGHT
...
waves = WaveSolutionTensor(array, dir_axis(SOL, basis=dir_basis), ...)
...
... waves.unwrap(dir_axis, ...)[LEFT, ...]   # лево и право
... waves.unwrap(dir_axis, ...)[RIGHT, ...]  # вместо магических 0 и 1
```

Мы не просто улучшили возвращаемый тип данных, добавив базис-направление.
Есть ещё пара преимуществ.

В предметной области есть разделение на решения `SOL` и компоненты `COMP`.
Решения сортируются по направлению `DIR` и всему остальному,
то есть направление волны находится на уровень ниже
в иерархии классов осей массива.
В коде `DIR` и `SOL` были как-бы на равных, что создавало путаницу.
Теперь путаницы нет, потому что нет `DIR`.
Вместо него теперь `SOL` + `basis=dir_basis`.

Раньше нужно было готовить параметры осей `DIR`/`SOL`/`COMP` для работы с ними
класса `SquareMatrixTensor`, который оперирует понятиями `COL`/`ROW`.
Сложности возникали из-за разделения `DIR`/`SOL`.
Теперь всё просто: `SOL=COL`, `COMP=ROW`,
больше не нужны дополнительные типы данных
и лишний этап обработки параметров осей.


### 3.2 Метод класса вместо метода экземпляра
Система классов-тензоров в моей расчётной программе устроена так,
что каждый класс в иерархии может иметь свой небольшой DSL для настройки
особых параметров осей тензора.
Например, для матриц можно указать какие оси будут строками и столбцами.

Инициализация происходит в два прохода.
Сначала двигаемся вверх по иерархии и обрабатываем параметры осей,
потом, когда инициализация базового класса `Tensor` завершилась,
двигаемся вниз по иерархии и завершаем настройку классов-потомков:
```Python
class MyTensor(Tensor):
    ...

    def prepare_params(
            self, param_axes: tuple[ParamAxis, ...]
            ) -> tuple[ParamAxis, ...]:
        # обработка: param_axes -> new_param_axes
        return super().prepare_params(*new_param_axes)

    def post_init(self):
        super().post_init()
        # завершаем настройку

    ...
```
Это сделано для того, чтобы, например, класс `BasisTensor`
мог задать размеры осей на основе размеров базисов (при проходе вверх),
а класс `WaveSolutionTensor` мог использовать
информацию о строках и столбцах класса `MatrixTensor`.

Трудность в том, что в рамках метода `prepare_params`
классы получают `self`, а это слишком много.
Даже у меня в коде инициализация классов была разделена между двумя методами:
часть полей заполнялась в `prepare_params`.

Во-первых, нельзя отдавать весь экземпляр класса функции,
которая должна только обработать свои параметры,
поэтому `prepare_params` должен быть `@classmethod`.
Такой метод (в отличие от статических методов) по-прежнему поддерживает
полиморфизм и позволяет организовать цепочку вызовов по иерархии классов.
Отличие в том, что у него нет доступа к экземпляру класса.
Поскольку работа с некоторыми типами тензоров требует отличать разные экземпляры
на уровне параметров осей, в этот метод будем передавать `id` экземпляра,
который уникален для всех объектов (которые пока не "съел" сборщик мусора).
В отличие от `self` такой подход не даёт простого доступа к экземпляру.

Во-вторых, нужно формализовать поведение классов-потомков на уровне
спецификации, и проверять соответствующее поведение на уровне тестов.
```Python
class MyTensor(Tensor):
    ...
    
    @classmethod
    def prepare_params(
            cls, uid: int, param_axes: tuple[ParamAxis, ...]
            ) -> tuple[ParamAxis, ...]:
        """
        This method should:
          - convert user axis parameters to internal parameters;
          - prepare new user parameters to be processed by parent classes;
          - pass prepared parameters to parent classes like
            `return super().prepare_params(uid, new_params)`.

        The internal parameters must be sufficient to completely setup
        the class instance within `post_init` method provided all parent
        classes are setup correctly;

        If the internal parameters differ from user-friendly parameters,
        then they must:
          - indicate (if found by this method) that the parameterized axis
            is taken from another tensor's `param_axes` property and thus has
            internal parameters for all parent classes (so all parent classes
            will also be setup correctly);
          - be not a part of public interface in any way, i.e. they are
            not supposed to be set or read by user or any child/parent classes
            (only user parameters should be used to communicate with parent
            classes);
          - be dropped/modified by this method in favor of user parameters.
            if there is any conflict.

        The unique instance identifier can be used to form internal parameters
        different for any existing instances if needed.
        """
        return param_axes
    
    def post_init(self):
        """
        This method should:
          - finish initialization of parent classes like
            `super().post_init()`;
          - finish initialization of this class supposing that all internal
            parameters are set up and can be retrived from `self.param_axes`.
        """
        pass

    ...
```


### 3.3 Автоматический вызов методов родительских классов
В предыдущем примере можно случайно забыть вызвать метод `super()` в нужном
месте.
Чтобы избежать этой неприятности, я автоматизировал процесс вызова методов
в нужном порядке относительно иерархии классов:
```Python
# Получить последовательность классов, переопределяющих заданный метод
# в том порядке, в котором они идут в Method Resolution Order (MRO)
# заданного класса
def _call_chain(tp: type, method: str) -> tuple[type, ...]:
    return tuple(t for t in tp.mro() if method in t.__dict__)

class Tensor(_BasicTensor):
    ...
    
    def __init__(
            self,
            array: NDArray[Any, Any],
            *patterns: ParamAxisPatternArg):
        ...
        # Готовим параметры
        param_axes = self.__prepare_params(axis_data.param_axes)
        ...
        # Завешаем инициализацию
        self.__post_init()

    def __prepare_params(
            self, param_axes: tuple[ParamAxis, ...]
            ) -> tuple[ParamAxis, ...]:
        # Теперь мы сами передаём правильный `uid` в метод каждого класса,
        # а не возлагаем надежды на реализацию классов-потомков.
        uid = id(self)
        # Вызываем метод `prepare_params` на наборе параметров вдоль MRO
        # В стиле ФП вместо цикла используем `reduce`
        return reduce(
            lambda pa, t: t.prepare_params(uid, pa), #type: ignore
            _call_chain(type(self), "prepare_params"),
            param_axes)

    @staticmethod
    def prepare_params(
            uid: int, param_axes: tuple[ParamAxis, ...]
            ) -> tuple[ParamAxis, ...]:
        """..."""
        return param_axes
    
    
    def __post_init(self):
        # Вызываем метод `post_init` в направлении обратном MRO
        # Здесь меняется состояние `self` и используется императивный стиль
        for t in reversed(_call_chain(type(self), "post_init")):
            t.post_init(self) #type: ignore
    
    
    def post_init(self):
        """..."""
        pass
```
Теперь при создании нового типа тензоров не нужно думать о том,
как и когда вызывать `super()`.

И кстати, теперь `prepare_params` - статический метод, которому не нужен ни
экземпляр класса, ни сам класс.


### Выводы
Иногда путь наименьшего сопротивления (классические методы экземпляров,
которые работают с `self`), при котором код выглядит проще,
в итоге всё усложняет.
В первой версии при реализации классов-потомков нужно было самому
следить за корректностью вызова `super()` и передачи параметров.
В последней версии, базовый класс `Tensor` берёт максимум работы на себя.
Для этого потребовалось использовать разную "экзотику"
вроде `orm()` и `__dict__`, но она спрятана за интерфейсом, работа с которым
стала гораздо проще.


## Общие выводы
Надежда на недокументированные возможности, и недокументированное поведение -
в долгосрочной перспективе это всегда ведёт к проблемам.
Лучше делать разные части кода максимально независимыми, ограничивая доступ
на уровне типов, или, хотя бы спецификации.
То есть, желательно формально, а лучше - функционально запрещать использование
недокументированных возможностей.

Интерфейс должен быть интуитивно понятным, и все его особенности должны быть
вынесены в документацию на видное место.
У нас же нет цели что-то скрыть, осложняя жизнь другим разработчикам
(включая себя самого через пару-тройку месяцев).

Простота интерфейса важнее простоты реализации.
Если есть возможность автоматизировать реализацию наших ожиданий и снять
часть когнитивной нагрузки с других разработчиков -
это обязательно нужно сделать.
