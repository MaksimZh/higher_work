# Ускоряем код фреймворков в 100 раз


## 1. Как писать код для веб-фреймворков, который работает в 100 раз быстрее
Я бы не поверил, что в серьёзных проектах кто-то использует ORM так,
как про это рассказывается в статье.
Но, блин, я видел эти сайты, которые спотыкаются при выводе любого списка.
Это и сайты госучреждений и частных компаний, и даже в сфере IT.
Самое разумное объяснение таких тормозов - это то, что там и правда
на каждый клик идёт выгрузка половины базы данных и крутятся вложенные циклы :(

Правильно думать о базе данных именно как о базе **данных**, а не объектов.
Если нам нужно именно обрабатывать данные так, как это умеет БД
(поиск, фильтрация, сортировка, некоторые простые вычисления и т.п.),
то и делать это нужно именно на стороне БД с помощью SQL запросов.
Если нужны более сложные манипуляции, какие-то нетривиальные алгоритмы,
то тогда это должны быть процедуры, которые получают данные подготовленные
самой БД настолько, насколько возможно.

Вот такое правило я для себя вывел:
 1. разбивать любую процедуру, обращающуюся к БД, на SQL и не-SQL часть;
 1. если есть сомнения куда отнести конкретный шаг обработки данных,
    его нужно отнести в SQL.


## 2. ORM в Django
В Django есть особый вид классов - модели, которые отображаются
(в математическом смысле) в таблицы БД.
Поля внутри такого класса описывают поля в соответствующей таблице
(тип данных, значение по умолчанию, и т.д.).


### Получение данных
Для получения данных из базы в Django используется DSL, основанный на
объектах, которые называются `QuerySet`.
Это часто переводят как "набор запросов", но в том то и дело, что это никакой
не набор, и тем более там нет запросов, поэтому я буду использовать
английский термин, чтобы не вводить самого себя в заблуждение относительно
природы этих объектов.

Здесь используются ленивые вычисления, и запрос к БД происходит тогда,
когда нам понадобятся сами данные, точнее, когда выполняется одна из следующих
операций:
 1. итерация по объекту `QuerySet`;
 1. обращение по индексу (сечению) к элементу (элементам) `QuerySet`
    (количество полученных элементов ограничивается на уровне SQL запроса!);
 1. сериализация (pickling) объекта `QuerySet`;
 1. преобразование в строку (`repr(query_set)`)
    или список (`list(query_set))`);
 1. вычисление длины (`len(query_set)`) или преобразование в булевский тип
    (`if query_set: ...`);
 1. извлечение единственной записи методом `get`;
 1. любая команда для модификации записей в базе (см. далее).

В общем случае запрос формируется примерно так:
```Python
# Получить не более 10 записей с полем some_value <= 5
MyModel.objects.filter(some_value__lte=5)[:10]
```
Получим примерно следующее:
```SQL
SELECT * FROM my_model WHERE some_value <= 5 LIMIT 10
```
> Синтаксис `LIMIT` работает не на всех движках БД, кое-где нужны другие
ключевые слова.
Об этом Django позаботится сам.


### Создание и модификация записей
Создание экземпляра класса-модели не меняет БД.
Для записи данных в базу нужно вызвать метод `save` у объекта,
тогда выполняется SQL запрос `INSERT`.

Для создание нескольких записей *одним SQL запросом* желательно использовать
метод `ModelClass.objects.bulk_create`.

Если объект уже в базе данных, то вызов `save` выполняет запрос
`UPDATE`.
Если при этом мы хотим изменить только часть полей в записи,
то запрос можно оптимизировать, добавив параметр с именами этих полей:
```Python
item.save(update_fields=["field1", "field2"])
```

Отдельные поля можно изменять сразу для нескольких записей
с помощью метода `update` у `QuerySet`, который "выбирает" эти записи
(на самом деле будет `UPDATE` а не `SELECT`),
или с помощью метода `ModelClass.objects.bulk_update`.


### Выводы
Похоже, что создатели Django создали DSL для запросов, который покрывает
практически все возможности SQL.
При этом он является абстракцией, которая (теоретически) может работать и с БД,
которые используют другие протоколы (не SQL) для доступа к данным.
Однако, на [официальном сайте](https://code.djangoproject.com/wiki/NoSqlSupport) сказано:
> This is not part of the official Django development efforts

При работе с Django я предпочту использовать `QuerySet`,
а не SQL, по следующим причинам:
  * за ошибки меня отругает линтер на этапе набора кода, а не БД в рантайме;
  * моего опыта не хватает чтобы представить нечто, что в этом DSL сделать нельзя;
  * эта абстракция (теоретически) покрывает и NoSQL - вдруг пригодится.

Извлекать все записи и фильтровать их вручную я точно не буду.


## 3.4.5. Реальный код
Мой (пока) единственный веб-проект был заморожен на этапе, когда БД ему ещё
не понадобилась.
Так что буду фантазировать как можно сделать что-то плохо и хорошо.

Рассмотрим, например, комплекты товаров в интернет-магазине.
Это как ноутбук + мышь + антивирус от Касперского,
и если берёшь всё сразу, то скидка 5% за комплект.

В БД будет две таблицы: `goods` для товаров и `bundles` для комплектов.
Ещё нужна будет служебная таблица, чтобы реализовать отношение
многие ко многим, но это Django сделает сам.

```Python
class Goods(Model):
    name = CharField(...)
    price = MoneyField(...)
    ...

class Bundles(Model):
    name = CharField(...)
    discount = DecimalField(...)
    goods = ManyToManyField(Goods) # !!!
    ...
```

### A. Список комплектов с ценами
По смыслу предметной области мы хотим получить названия комплектов с их ценами.

Плохо
```Python
# SELECT * FROM bundles;
for bundle in Bundles.objects.all():
    # SELECT * FROM goods WHERE id = <bundle.id>;
    sum_price = sum(item.price for item in bundle.goods.all())
    real_price = sum_price * bundle.discount / 100
    print(bundle.name, real_price)
```

Хорошо
```Python
Bundles.objects.annotate(
    real_price = Sum(F("goods__price")) * 100 / F("discount")
    ).only("name")
```
Это один запрос, примерно такой:
```SQL
SELECT
    bundles.name,
    (SUM(goods.price) * bundles.discount / 100) AS real_price
FROM
    bundles
    LEFT OUTER JOIN bundles_goods ON (bundles.id = bundles_goods.bundles_id)
    LEFT OUTER JOIN goods ON (bundles_goods.goods_id = goods.id);
```

Здесь следующие плюсы:
  * один запрос, вместо запроса под каждый комплект;
  * берём только те поля, которые нужны - передаём меньше данных;
  * вычисления на стороне базы данных - передаём меньше данных,
    возможность кэширования результатов.


### B. Самая большая скидка на товар
Мы хотим получить названия и величины скидок комплектов,
где товар продаётся с самой большой скидкой.

Плохо
```Python
key=itemgetter(1)
groupby(
    sorted(
        (bundle.name, bundle.discount) for bundle in item.bundles.all(),
        key=key, reverse=True),
    key=key)[0][1]
```

Хорошо
```Python
item.bundles.annotate(max_discount=Max("discount")).only("name")
```
```SQL
SELECT
    bundles.name,
    MAX(bundles.discount) AS "max_discount"
FROM
    bundles
    INNER JOIN bundles_goods ON (bundles.id = bundles_goods.bundles_id)
WHERE bundles_goods.goods_id = <item.id>
```
  * мы получаем только те записи, где значение скидки максимально;
  * нам не нужно вручную сортировать список.


### C. Сортированный список комплектов, содержащих данный товар
Хотим предложить несколько самых дорогих комплектов покупателю,
который смотрит конкретный товар.

Плохо
```Python
sorted(
    (
        bundle.name,
        sum(i.price for i in bundle.goods.all()) * bundle.discount / 100) \
    for bundle in item.bundles.all(),
    key=itemgetter(1), reverse=True)
```

Хорошо
```Python
item.bundles.annotate(
    real_price = Sum(F("goods__price")) * 100 / F("discount")
    ).order_by("-real_price").only("name")
```
```SQL
SELECT
    bundles.name,
    ((SUM(goods.price) * 100) / bundles.discount) AS real_price
FROM
    bundles
    INNER JOIN bundles_goods ON (bundles.id = bundles_goods.bundles_id)
    INNER JOIN goods ON (bundles_goods.goods_id = goods.id)
WHERE bundles_goods.goods_id = <item.id>
ORDER BY real_price DESC
```
  * один запрос, вместо запроса под каждый комплект;
  * берём только те поля, которые нужны;
  * вычисления на стороне базы данных;
  * сортировка на стороне базы данных.


### Выводы
Видно, что "хороший" код на Python, который максимально использует
возможности SQL, получился компактнее и понятнее, чем "плохой".
Это при том, что я старался исключить использования изменяемых состояний,
сделав "плохой" код декларативным, иначе там могли и вложенные циклы оказаться.

При работе с БД в Django лучше думать о моделях именно как об образах таблиц,
и избегать работы с ними как с АТД в объектной модели.
Какие данные нужны для работы конкретного алгоритма - такие и нужно запрашивать.
Причём в том виде и количестве, в каком хотим их обрабатывать,
а не как они в таблицах лежат.
Для этого есть все возможности - `annotate`, `only` и т.п.


## Общие выводы
Если не ошибаюсь, в книге "Чистая Архитектура" Роберт Мартин предупреждает,
что фреймворки спроектированы таким образом,
что легко вторгаются во все места программы, на всех уровнях абстракции.
Неправильное использование экземпляров классов-моделей в Django -
как раз пример такого вторжения.

Алгоритм, внутри ядра бизнес-логики программы должен работать со своими АТД,
которые не знают ничего ни о каких базах данных, клиентах, серверах,
HTTP-запросах и т.д.
Если мы подменяем эти АТД элементами ORM, то не только проигрываем в скорости,
но ещё и портим архитектуру программы, создавая зависимость от структуры БД
там, где это совсем не нужно.
Правильное проектирование должно задвинуть ORM куда-то
во область адаптеров и обёрток, которые связывают основное приложение с
внешними библиотеками.

Важно понимать для чего нужны эти объекты в ORM
(и надеяться, что создатели фреймворка тоже это понимают).
Если мы думаем, что в Django модель - это образ таблицы, то место ей в
обёртке, которая отвечает за работу с БД, и зависимость от неё в приложении
должна быть минимальной.
Если мы думаем, что модель - это образ элемента предметной области,
то она попадёт в бизнес-логику, а там и до обращениям к БД в каждой итерации
цикла недалеко.
