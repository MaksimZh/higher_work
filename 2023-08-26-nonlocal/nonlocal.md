# Размеры осей
Следующий код интерпретирует одномерный массив как тензор ранга 2
размерности 4 на 4:
```Python
t = Operator(
    np.arange(10, 10 + 4 * 4),
    k_left(k_basis_1xyz)[4] * k_right(k_basis_1xyz)[4])
```
При этом к каждой из осей привязывается базис из 4-х элементов.

Для того, чтобы не указывать размер явно в таких случаях
было решено объединить механизмы привязки произвольных данных к осям
и механизм задания размера.

Раньше оператор `()` создавал на основе оси объект класса `TabAxis`,
а оператор `[]` - `SizeAxis`:
```Python
class Axis:
    ...
    
    def __getitem__(self, size: int) -> "SizeAxis":
        return SizeAxis(self, size)
    
    def __call__(self, tag: Any) -> "TagAxis":
        return TagAxis(self, tag)
```
Теперь оператор `[]` создаёт объект `TagAxis` с тегом специального типа `SizeTag`:
```Python
class Axis:
    ...
    
    def __getitem__(self, size: int) -> "TagAxis":
        return TagAxis(self, SizeTag(size))

    def __call__(self, tag: Any) -> "TagAxis":
        return TagAxis(self, tag)

...

@final
class SizeTag:
    ...

    @property
    def size(self) -> int:
        return self.__size
```
Особое внимание стоит уделить свойству `SizeTag.size`.
Такое же свойство есть у любого базиса:
```Python
class Basis(ABC):

    @abstractproperty
    def size(self) -> int:
        assert False
```
Код, который отвечает за разбиение осей, может получить размер из любого тега,
который обладает этим свойством.
Теперь не нужно дублировать информацию о размере оси в базисе
и в квадратных скобках.

Для этого изменения было решено отказаться от сложной системы типов,
которая обеспечивала статическую проверку правильного указания размерностей.
Это позволило сделать автоматическое определение размерностей более гибким:
считывать их из базисов и считать одинаковыми для всех осей, где они не указаны:
```Python
t = Tensor(np.arange(3 * (2**3) * 5), a[3] * b * c * d * e[5]) # 3 x 2 x 2 x 2 x 5
```
