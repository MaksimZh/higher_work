# Формализуем понятие надёжности системы

## 1. Выводы по теории
В который раз убеждаюсь, что если мы хотим добиться в чём-то успеха
нужно хотя бы иметь возможность понять - добились мы его, или нет.
То есть, критерии успеха и неудачи нужно формализовать -
свести к математическим объектам.
Вообще, чем больше всего удастся свести к математике,
тем больше у нас возможностей для работы
с помощью математических методов.
Это, конечно, если мы эти методы хотим использовать.
В инженергых областях работу без них сложно представить.

То же касается и надёжности.
Нужно не "чтобы не ломалось", а количественные критерии.


## 2-4. Свойства системы
Моя нынешняя система скучная,
поэтому рассмотрим перспективную.
Интерфейсная часть - мобильное приложение для графического кодинга,
которое может выполняться на планшете, или даже на смартфоне.
Основная часть - сервер с облачным хранилищем для приложений,
где их можно скомпилировать.
Скомпилированное приложение может быть отправлено
в очередь на суперкомпьютер с нужными параметрами.
Результаты расчётов можно скачать на сервер,
или переправить в другое облачное хранилище.

Ключевые свойства следующие:

### 2-4.1. Время отклика мобильного приложения
Время, которое проходит между действием пользователя
и изменением на экране.
- узкий интервал: 0-50 мс;
- широкий интервал: 0-200 мс.

Инварианты:
- RESILENT 0-50 мс;
- STRONG 0-200 мс;

Влияние окружения может замедлить работу на время,
но если программа тормозит сама по себе, то это провал.


### 2-4.2. Время обновления облачной копии
Время, которое проходит между изменением программы
и полной загрузкой всех изменений на сервер.
- узкий интервал: 0-1 с;
- широкий интервал: 0-60 с.

Инварианты:
- RESILENT 0-1 с;
- STABLE 0-60 с.

Временные проблемы с сетью или перегрузка сервера
иногда замедляют систему, но мы должны быстро возвращаться к норме.


### 2-4.3. Наблюдаемое время компиляции
Время, которое проходит между командой на компиляцию из приложения
и получением ответа о результате компиляции.
- узкий интервал: 0-1 мин;
- широкий интервал: 0-10 мин.

Инварианты:
- WEAK 0-1 мин;
- RESILENT 0-10 мин.

Время зависит от сложности программы,
но в общем случае нужно стремиться укладываться в 10 мин,
если нет технических сбоев.


### 2-4.4. Заполненность хранилища на сервере
Не закончится ли у нас место под все эти программы?
- узкий интервал: 0-50%;
- широкий интервал: 0-99%.

Инварианты:
- RESILENT 0-50%;
- STABLE 0-99%.

Переполнение - это фиаско.
Нужно стремиться держать объём ресурсов достаточным
даже при растущих нагрузках.


### 2-4.5. Время ожидания
Время, между командой на запуск расчёта из приложения
и началом расчёта.
- узкий интервал: 0-8 ч;
- широкий интервал: 0-24 ч.

Инварианты:
- WEAK 0-8 ч;
- RESILENT 0-24 ч.

Тут многое зависит от загруженности кластера.


### Выводы по работе с инвариантами
Что меня больше всего раздражает в современных компьютерах и программах -
это огромное время отклика.
Пока одно из ядер процессора занято решением сотен дифуров в секунду,
ещё на 2х среда разработки героически перемещает курсор по тексту, и лагает.
Лагает не из-за дифуров, а из-за того, что это интерпретатор,
в котором запущена туча Java Script программ.
Вот сейчас остановлю службу "диспетчер очереди печати"
(который опять на 100% занял 4-е ядро, хотя принтер я в прошлый раз использовал дня 3 назад),
и, может, трёх ядер хватит, чтобы курсор нормально двигать.

И, конечно, главная фича 99% современных игр - задержка на 5-10 кадров в отклике на мышь.
Причём кое-где это отключается одной галочкой типа "raw mouse input",
то есть, проблема чисто программная.

Поэтому почти все инварианты выше - про ощущения пользователя,
для которого, в конечном счёте, вся система и создаётся.
Это как юниттесты в TDD - повод с самого начала подумать,
какое поведение ожидается.


## 5. Усиление инвариантов
Проще всего работать с инвариантами, завязанными на сервер.
Мы не можем отвечать за то, что проиходит с планшетом пользователя вне нашей программы,
и суперкомпьютер обслуживают совсем другие люди.

Первое, что можно усилить - время обновления облачной копии.
Можно изменить интерпретацию на интервал отправки изменений на сервер с гарантированной доставкой.
Сохранность кода и истории изменений важна.
Поэтому можно озаботиться дублированием каналов передачи,
наличием буферных хранилищ на случай сбоя на одном из серверов и т.д.
Я считаю, что при наличии стабильного интернет-соединения,
вполне достижимо STABLE 0-1 с.

Наблюдаемое время компиляции тоже можно уменьшить.
Кэширование результатов компиляции отдельных модулей на разных стадиях
(от первых шагов анализа до объектных файлов)
вместе с непрерывной фоновой работой (аналогично современным линтерам)
может создать ощущение, что программа компилируется почти мгновенно
и всегда готова к запуску.
Вместо WEAK 0-1 мин можно ставить RESILENT 0-10 с.

Скорость восстановления определяется конкретной инфраструктурой
и характером сбоев.
Дублирование оборудования увеличит скорость восстановления при отказах:
отключение одтельного сервера может вообще пройти незаметно.
Для противодействия DDOS атакам тоже есть проверенные методики.
Ну и, конечно нужно следить за нагрузкой и своевременно наращивать ресурсы.
Так что, да, скорость восстановления можно и нужно использовать. 


### Выводы
Всегда нужно задавать вопрос: "как сделать лучше?"
Тогда можно оценить требуемые ресурсы и думать о целесообразности.
Даже если пока "и так сойдёт",
потенциальные изменения могут быть идеей для стратегического развития продукта.
Идея с непрерывной фоновой компиляцией пришла только сейчас,
когда я писал предыдущий абзац.
Аа ведь это может стать решающим преимуществом новой системы.


## Общие выводы
Такой формальный подход к вопросам надёжности очень полезен.
Очевидно, что, по крайней мере в связи с пользовательским опытом,
он почти не применяется.
В современном мире применение таких методов даёт решающее конкурентное преимущество.
Для бизнеса - возможность оценки рисков на основе инвариантов.
Для пользователей - отсутствие вопроса "что ты там @#$%^ делаешь, вместо выполнения моих прямых указаний?"
