# Добиваемся совместимости между (унаследованными) типами

## 1. Free object
> Тип A будет свободным объектом,
  если для любого возможного альтернативного типа B
  (который поддерживает подмножество операций из A),
  можно преобразовать значение типа A в точно такое же значение типа B,
  которое мы получили бы, если бы начали с **тех же входных данных**
  и выполнили **те же операции**.

Для простоты представим, что значение типа A
можно представить точкой на координатной оси a,
а операции перемещают эту точку.
Если в одно и то же состояние можно попасть разными путями,
такое перемещение необратимо,
т.е. невозможно восстановить траекторию по конечной точке,
особенно если мы потеряли данные об операциях.

Хорошо, путь данные об операциях лежат на оси x,
и мы их не потеряли.
Даже в этом случае некоторые шаги могут происходить с потерей данных a.
Простой пример - остаток от деления.
Даже если мы знаем и делитель, и остаток - делимое неоднозначно.
То есть, нужно хранить координаты всех промежуточных точек (a, x).
Входные данные тут будут иметь вид (a0, Ox),
где Ox означает отсутствие операции,
или (Oa, x0), где Oa - "чистое" исходное состояние,
а x0 - входные данные.

Теперь пусть значения типа B лежат на оси b.
Тогда у нас будет две траектории: [..., (a, x), ...] и [..., (b, x), ...].
Даже если какая-то из них будет иметь самопересечения,
между каждой парой точек (a, x) и (b, x) можно установить
взаимно-однозначное соответствие,
поскольку помимо координат у них есть ещё и порядковые номера:
(n, a, x), (n, b, x).

Пусть какая-то операция (номер 5) для A идёт с потерей данных, а для B - нет:
```
a[4] != a'[4]   b[4] != b'[4]
a[5] == a'[5]   b[5] != b'[5]
```
Как зная только a[5] найти b[5] и b'[5]?
Никак.
Если же мы знаем a[4] и a'[4],
в точке до того, как две траектории в пространстве A схлопнулись,
то можем построить две разные траектории в пространстве B.


## 2. Примеры использования

### 2.1 Лабораторный журнал
При научных расчётах полезно было бы сохранить все входные данные,
а также те промежуточные результаты, которые тяжело достаются.
То, что сейчас промежуточные данные, потом может оказаться важным результатом,
или входными данными для других расчётов.
Поскольку ждать этого иногда нужно часами, проще заранее всё сохранить.

И, конечно, нужно вместе с результатами записывать версию
самодельной библиотеки и скрипта для расчётов
(вплоть до конкретного коммита).

Здесь свободным объектом является результат расчёта в широком смысле -
вместе с промежуточными результатами и особенностями используемой модели
(которую можно извлечь из входных данных и версии программы).


### 2.2 История рассеяния
При расчёте изменения распределения электронов по энергиям
методом Монте-Карло очень много промежуточных данных
интегрируется и забывается.
Есть несколько механизмов рассеяния и каждый "случайно" срабатывает
по несколько раз.
Информация о вкладе каждого вида рассеяния может понадобиться позже.
Хорошо бы её сохранить, а не только суммарный результат.

Хоть это и противоречит самой математической сути метода Монет-Карло,
идеально было бы сохранить информацию о всех актах рассеяния,
даже если это гигабайты.
Тогда в будущем можно будет проводить усреднения по другим критериям,
например, группировать события по виду рассеяния,
следить за изменением мощности излучения тепла и света и т.п.

Здесь свободным объектом снова является результат расчёта в широком смысле.
Только в этот раз сохранится "неповторимая" картина, созданная генератором
псевдослучайных чисел.
И кстати, параметры генерации этих чисел (seed) тоже лучше бы сохранить.


### 2.3 Карма
Мои программы, в основном, работают по принципу:
запустил расчёт - ушёл ~~в отпуск~~ обедать.
В принципе, даже работу генератора псевдослучайных чисел можно в точности
повторить, если сохранить все входные данные.
То есть, здесь нет недетерминированного воздействия, для которого сохранение
полной информации было бы критично.

Для разнообразия предположим, что мы делаем игру с открытым миром,
где у игрока есть возможность взаимодействия с множеством NPC.
В какой-то момент мы выпускаем обновление,
и теперь у NPC есть возможность запоминать свои "впечатления"
от общения с игроком, и это будет влиять на их отношение к нему,
и на отношения других членов той же семьи, организации, расы и т.п.

Если позади уже десятки часов игры и куча выполненных квестов,
хотелось бы, чтобы накопленная "карма" сразу же влияла на игровой процесс.
Для этого в каждой точке, где игрок делает выбор, нужно сохранить этот выбор.
Тогда при миграции данных на новую версию можно будет собрать всю
эту информацию и вычислить любые новые параметры.

Здесь в роли свободного объекта выступает состояние игрового мира
(в случае однопользовательской игры - сохранение).


## Выводы
Свободные объекты необходимы там, где эволюция данных недетерминирована.
А ещё они полезны там, где изменение детерминировано,
но его воспроизведение очень затратно. 
Как понять, нужен ли нам свободный объект в системе?
Если есть вероятность, что захочется путешествовать во времени, то да:
  - Вот бы узнать, с какими параметрами был выполнен этот расчёт!
  - Надо было добавить вычисление мощности излучения!
  - А герой выполнил тот квест подкупом, или угрозами?
  - и другие произведения от создателей "БД упала, но у нас есть СКРИНшоты".

Если чего-то подобного стоило ожидать, то свободный объект нужен.
