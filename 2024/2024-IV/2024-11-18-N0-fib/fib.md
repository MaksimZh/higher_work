# Задачка N 0

## 1. Исходный код

```Python
def fibs_sum():
    fsum = 0
    while True:
        fsum += yield fsum
     
def get_fibs(num):
    a, b = 0, 1
    gsum = fibs_sum()

    gsum.send(None)
    for i in range(num):
        yield gsum.send(b)
        c = b
        b = a + b
        a = c
```

В этом коде есть генератор, который накапливает сумму чисел,
переданных в метод `send` в качестве аргументов.
Вызов этого метода возвращает новую сумму (после добавления своего аргумента).

Последовательность Фибоначчи вычисляется в трёх последних строках,
но фактически, из-за вызова `gsum.send` возвращается не она, а её сумма.


## 2. Исправление
Простой способ исправить ситуацию - вовсе убрать суммирование:

```Python
def get_fibs(num):
    a, b = 0, 1
    for i in range(num):
        yield b
        a, b = b, a + b
```

Если уж очень хочется использовать для суммирования именно генератор,
то возможен и такой вариант:

```Python
def fibs_sum():
    fsum = 0
    while True:
        fsum += yield fsum
     
def get_fibs(num):
    a, b = 1, 1
    gsum = fibs_sum()

    gsum.send(None)
    for i in range(num):
        a, b = b, gsum.send(a)
        yield a
```

Выглядит довольно запутанно.


## Выводы
Было очень сложно разбираться с методом `send`,
с которым я здесь столкнулся впервые.
Он не только меняет состояние генератора, но и возвращает значение,
то есть, это не запрос или команда в чистом виде, а некоторая смесь.
Одновременно с этим `yield`, оказывается,
не только отправляет значение в вызывающий код,
но может и принимать значение оттуда,
а может и не принимать.
То есть, он тоже делает (или не делает) две вещи одновременно,
и мы не знаем делает или не делает, нужно проверять результат на `None`.

Получается, что `next` вызывает генератор без аргументов
и возвращает значение,
а метод `send` вызывает генератор с одним аргументом
и тоже возвращает значение.
В то же время `yield` вызывает вызывающий код с одним аргументом
и возвращает значение.
При этом все три метода меняют состояние в вызываемом коде.
Лично мне кажется, что это всё создаёт лишнюю сложность
и точку притяжения ошибок.

Лучше бы сделать `yield` командой,
а все данные передавать в генератор в качестве входных параметров.
Кому нужно, чтобы две нити обменивались данными -
пусть использует для этого расширенный протокол с дополнительным запросом
к вызывающему коду.

Снаружи генератора метод `next` должен быть командой,
а для получения текущего элемента и проверки на пустоту
нужны отдельные запросы.
Сейчас конец последовательности можно отследить только отлавливая исключение,
что уж совсем некрасиво:
**исключение - это исключительная ситуация**,
за пределами нормального потока выполнения,
а конец последовательности - это как раз норма.
Опять же, если нужно передавать данные в генератор посреди работы -
используйте отдельную команду.
