# Триплы Хоара

## Задача 1
Как можно изменить этот код, чтобы постусловие оставалось истинным?
```C
{ true }
a = 10;
{ a > 1 }
b = 42;
{ a > 1, b > 1 }
c = a + b;
{ c > 1 }
```

### 1.1
```C
{ true }
a = 2;  // a = 10;
{ a > 1 }
b = 2;  // b = 42;
{ a > 1, b > 1 }
c = a + b;
{ c > 1 }
```
Просто меняем исходные данные на другие, удовлетворяющие тем же постусловиям.


### 1.2
```C
{ true }
a = 10;
{ a > 1 }
b = 42;
{ a > 1, b > 1 }
c = b - a;  // c = a + b;
{ c > 1 }
```
Меняем операцию, но результат по-прежнему удовлетворяет постусловию.


### 1.3
```C
{ true }
a = 100; // a = 10;
{ a > 1 }
b = 42;
{ a > 1, b > 1 }
c = a - b;  // c = a + b;
{ c > 1 }
```
Меняем операцию и входные данные так, чтобы все постусловия выполнялись.


### 1.4
```C
{ true }
a = 10;
{ a > 1 }
b = a - 5;  // b = 42;
{ a > 1, b > 1 }
c = a + b;
{ c > 1 }
```
Делаем входные данные зависимыми, но удовлетворяющими тем же постусловиям.


Условия довольно общие, и им удовлетворяет множество вариантов кода.
Важно то, как они соотносятся с логикой программы.
Может, важно, что `c > 1` **для любых** `a > 1` и `b > 1`?
Тогда вычитание выдаст ошибочный результат для большого класса входных данных,
но но эту ошибку можно будет отловить только тестами в рантайме,
либо при попытке формально доказать корректность кода.


## Задача 2
Заполнить пустые места правильными условиями
```C
{  }
b = 2 - a;
{  }
c = b * 2;
{  }
d = c + 1;
{d  =  5}
```

Решение:
```C
{ a = 0 }
b = 2 - a;
{ b = 2 }
c = b * 2;
{ c = 4 }
d = c + 1;
{ d = 5 }
```
Одно из условий уже дано, поэтому отталкиваемся от него и решаем уравнения
для неизвестных переменных.


## Размышления
Хотим ли мы в первой задаче, такого:
```
c > 1 ∀ a > 1, b > 1
```
или
```
a > 1 ∧ b > 1 => c > 1
```

Если читать код как группы триплов Хоара, то именно так и получается:
```C
{ a > 1, b > 1 }  // Если `Предусловие` истинно, то
c = a + b;        // после выполнения `Команды`
{ c > 1 }         // `Постусловие` будет истинно
```
Тогда, конечно, вычитание не подходит, и ошибка должна ловиться
на уровне статического анализа кода, а не в рантайме,
иначе все эти условия теряют смысл, превращаясь в набор ассертов:
```C
assert(a > 1 && b > 1);  // Если `Условие` ложно, то ошибка
c = a + b;
assert(c > 1);           // Если `Условие` ложно, то ошибка
```

Можно ли как-то записать более сложные спецификации?
Например, как запишутся условия FIFO и LIFO для очереди и стека соответственно?
В трипл для одной команды такое, вроде бы, не влезает,
если только не делать порядок данных частью пред- и постусловий.
Так что нужно работать с последовательностями команд:
```
{}
queue.push(a)
queue.push(b)
c = queue.pop()
d = queue.pop()
{ (c, d) == (a, b) }
```
```
{}
stack.push(a)
stack.push(b)
c = stack.pop()
d = stack.pop()
{ (c, d) == (b, a) }
```
Такого, правда, недостаточно.
Нужно формальное определение корректной последовательности команд `com`,
которое означает, что мы не извлекаем данные из пустого контейнера:
```
invariant: n(com) >= 0
n([]) = 0
n(com + [push]) = n(com) + 1
n(com + [pop]) = n(com) - 1
```
После этого можно говорить о формализации
определений входных и выходных данных,
а также закона, по которому последовательность входных данных отображается
в последовательность выходных:
```
invariant: size(input) = com |> map n |> filter positive |> sum
fifo(com, input) = input[0 .. size(input) - n(com)]
lifo(com, input) = input[... упс!
```
Со стеком без рекурсии не обойтись:
```
lifo([], []) = []
lifo(com + [push], input + [v]) = lifo(com, input)
lifo(com + [pop], input + [v]) = lifo(com, input) + [v]
```
Вот бы такое можно было сделать частью определения типа `Queue`/`Stack`,
и чтобы линтер потом ругался:
```Python
s = Stack()
s.push(1)
s.pop()
s.pop()  # Command preconditions not satisfied
```
```Python
def foo(stack: Stack):
    stack.pop()  # Command preconditions may be not satisfied
```
```Python
s = Queue()
s.push(1)
s.push(2)
s.pop()
assert s.front == 1  # Assertion always fails
```
