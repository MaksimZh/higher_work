# Группировка в функциях и файлах

## 1. Теория
Узнал вот какой лайфхак: если функция (класс, модуль) получилась большой,
и/или явно состоит из нескольких частей,
то не нужно сразу стараться разбить её на отдельные функции (классы, файлы).
Такое разбиение увеличивает нелокальность логики внутри программы.
Например, при чтении функции может потребоваться перейти в конец файла,
или в другой модуль, а потом прыгать обратно.
Структура кода и её восприятие глобально усложняются, хотя кажется,
что локально всё стало проще.

Есть другой подход - схлопывание (folding) кода.
Для этого в C-подобных языках можно использовать блоки `{ }`,
а в Python, например, специальные комментарии.
Лишь бы среда разработки это всё поддерживала.
Тогда общая логика функции может разместиться на одном экране,
а детали можно легко посмотреть на месте.


## 2. Практика

### 2.1. Решатель дифуров
Функция очень большая, и я давно хотел её разбить на части,
но при этом в подфункции пришлось бы передавать слишком много аргументов,
и хорошего решения я пока не нашёл.
Логически, помимо проверки и подготовки аргументов со значениями по-умолчанию,
здесь происходит распаковка тензоров в массивы NumPy,
решение дифуров средствами SciPy
и упаковка результата обратно в тензорный вид:
```Python
def solve(
            self, initial: Tensor, mesh: Tensor,
            shift: float | Tensor = 0, scale: float | Tensor = 1,
            atol: Optional[float] = None, rtol: Optional[float] = None,
            ) -> Tensor:
        #region: Check and prepare args...

        #region: Prepare raw data...
        
        #region: Solve the ODE...

        #region: Pack the result...

```

### 2.2. Класс `Tensor`
Здесь есть внутренние данные и интерфейс для их чтения (свойства).
Для удобства использования инициализация предлагает несколько вариантов,
поэтому она довольно сложна и достойна отдельного блока.
Также отдельно можно выделить то,
что делает тензор похожим на массив NumPy:
поддержка индексов и сечений, а также
поэлементного применения математических функций.

Заключительный блок содержит вспомогательные функции,
и он, кстати, дополняется гораздо чаще других.
Так что здесь код разделён на блоки не только по логике,
но и по частоте изменений.
```Python
class Tensor(MROChain, np.lib.mixins.NDArrayOperatorsMixin):
    #region: Fields and properties...

    #region: Initialization...

    #region: Array interface...

    #region: Auxiliary functions...
```


### 2.3. Тест класса `Tensor`
Раньше для тестирования разный аспектов поведения тензора
я использовал разные классы.
Потом я научился запускать тесты родительского класса `Tensor`
для потомков, чтобы проверять их на соответствие LSP.
При этом гораздо удобнее объединить набор тестов в одном классе,
но какой же он большой!

Чтобы не путаться, я разбил методы-тесты на группы:
```Python
class Test_Tensor(TensorTest):

    #region: Core stuff...

    #region: Simple initialization tests...

    #region: Complex packing tests...

    #TO be continued
```


### Выводы по работе с кодом
Расчленение функций и классов - это большая когнитивная нагрузка
и большой риск добавить ошибок.
Группировка кода требует куда меньше усилий и не меняет поведение программы.
Это не только хорошее начало перед рефакторингом.
Можно оставить всё как есть сильно улучшив восприятие кода
с минимумом действий.


## Общие выводы
В моём большом pet-проекте прогамма вместо текста представляется в виде графа.
Принципиальный момент здесь - многомерность,
что отличает такой способ кодирования от одномерного линейного текста.

Помимо измерений в плоскости тут будет доступна ещё и глубина.
Часть графа можно будет сгруппировать и свернуть в одиночный узел,
и эту конструкцию можно будет сделать многоуровневой.
Схлопывание блоков текстового кода даёт ту же возможность,
делая текстовый код немножко многомерным.

Преимущество графического кода в том,
что все входящие и исходящие связи узла будут показаны автоматически.
В тексте же нужно развернуть блок, чтобы увидеть
на какие локальные переманные он ссылается
(или же вручную выписывать всё в комментарий-заголовок).
