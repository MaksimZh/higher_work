# Применяем функциональную композицию правильно

## 1. Теория
Следуя "классическому" ООП подходу,
если нам нужно посчитать зарплату работника с учётом премий,
то следует наплодить кучу наследуемых классов.
Как минимум нужен класс для расчёта зарплаты, класс для расчёта премии,
родительский класс абстрактного рассчёта
и ещё один класс-потомок - для комбинирования абстрактных рассчётов.
Ух!

А если это ещё и Java с требованием размещать каждый класс в отдельном файле,
то для работы с таким кодом желательно иметь 2-3 дополнительных монитора.

Это всё при том, что в подавляющем большинстве
современных языков программирования большая часть этих "классов" уже есть.
Для вычислений можно использовать функции,
а для их комбинирования - композицию функций.
С помощью лямбда-выражений код можно сделать достаточно компактным,
наглядными и легко модифицируемым.

По сути, на уровне логики и тот и другой код эквивалентны.
Просто в первом случае логические элементы `вычисление` и `комбинация`
отображаются в не совсем удачные элементы кода - классы,
и для того, чтобы их правильно соединить,
появляется необходимость в наследовании.
Функции тут подходят куда лучше прежде всего из-за синтаксического сахара:
компилятор сделает большую часть работы сам, без ручного создания классов
и их искусственных иерархий.

Другой вариант "лишнего" наследования - повторное использование кода.
С учётом требований LSP и потенциальных обновлений кода,
родительский класс может принести с собой гораздо больше,
чем хотелось бы.
Куда лучше ограничить его влияние на новый код,
используя обёртку вокруг ограниченного подмножества API.


## 2. Практика

### 2.1. Иерархия тестов
Есть постоянно расширяющаяся иерархия классов,
в которой хочется автоматически запускать юниттесты родителей для потомков.
Для этого класс с тестами родителя
наследуется и дополняется тестами для потомка.

Тесты предполагают создание экземпляров классов, и сложность в том,
что этот процесс не подчиняется LSP.
То есть, аргументы конструктора,
которые подходят для создания экземпляра родительского класса,
могут быть некорректны для некоторых классов-потомков.
Например, абстрактный тензор может иметь любой ранг,
хоть нулевой (это будет скаляр),
а матрица рассеяния, по определению, должна иметь хотя бы два измерения.

Чтобы корректно запускать тесты для нетривиальных потомков,
класс родителя содержит поле `sample`,
которое задаёт минимальный корректный экземпляр тестируемого класса.
Родительский тест анализирует это поле и создаёт класс `SampleData`
с информацией для создания и проверки других тестовых экземпляров.

Трудность в том, что иерархия многоуровневая,
и для класса нужно запускать тесты
не только родителя, но и "дедушки" с "прадедушкой".
Для тестирования на дополнительных уровнях
может понадобиться дополнительная вспомогательная информация,
и в результате понадобится ещё и параллельная иерархия для `SampleData`.

Решение вот какое - поместить всю информацию для тестирования 
в сами тестовые классы в виде геттеров, переопределяемых потомками.
Тогда `SampleData` не понадобится и достаточно будет одной иерархии классов.

Для уменьшения количества классов здесь вместо отдельных функций
используются методы других классов, которые тоже немножко функции.


### 2.2. Виджеты
Для снижения зависимости от сомнительных библиотек и в качестве тренировки
в своём пет-проекте решил сделать собственную систему виджетов для GUI.
Так и напрашивается создать класс `Widget` и потом от него всё унаследовать.
Во имя инкапсуляции, рисовать виджеты должны себя сами
с помощью всяких `drawBefore` и `drawAfter`,
прямо как в популярных фреймворках типа [Kivy](https://kivy.org).
Ещё можно сделать комбинированные виджеты, например,
числовое поле с кнопками для инкремента и декремента.
Такой виджет должен сам для себя создать внутренние части
и обрабатывать события для них.

Получается, что система классов,
которые много чего умеют на грани нарушения SRP.
При этом структура GUI будет задаваться с помощью кучи связанных классов
не очень прозрачных для внешнего воздействия.
При этом совсем недавно я прочитал умную мысль,
что хорошо бы задавать эту структуру декларативно
в виде комбинации легковесных и прозрачных элементов типа записей.

Одним из плюсов такой прозрачной структуры является то,
что вместо обхода дерева и вызова методов отрисовки по одному,
можно использовать функциональный подход.
Сначала обрабатываем эту структуру,
собирая данные об изображениях в один большой `VertexArray`,
а потом делаем `glDrawArrays`.
Раз современные видеокарты позволяют разделить процессы загрузки данных
и рисования - почему бы этим не воспользоваться?

Как же быть со сложными виджетами?
А пускай вместо конструкторов они создаются функциями.
Функция `numberField` создаст легковесные виджеты
и для текстового поля, и для кнопок, и для обёртки,
потом она настроит обработчики событий
для обновления содержимого текстового поля с помощью кнопок.
Тогда не нужны ни сложные конструкторы классов, ни наследование.
Будет повторное использование кода,
но не кода методов класса за счёт наследования,
а кода чистых функций за счёт композиции.


### 2.3. Entity Component System
Элементы виртуального мира в компьютерных играх -
это такие виджеты на стероидах.
Они тоже интерактивные, но часто ещё и активные, и с динамически
меняющимся набором свойств и сценариев поведения.
А ещё, фантазия геймдизайнеров безгранична и динамична,
как и желания игроков.
Поэтому, то, что происходит нельзя даже назвать
"изменением требований заказчика".
Это скорее "требование постоянных изменений".

В некоторых учебных статьях по ООП иерархия классов в играх
используется как иллюстрация,
но в индустрии такой подход применяется крайне редко.
Стандартом (используемым, например, в Unity и Unreal Engine)
является подход Entity Component System (ECS),
суть которого в том, что сущности игрового мира
в принципе не являются объектами.

Вместо сложной иерархии классов используется плоская система
из сущностей (**entity**) одинакового типа (иногда это просто числовой UID).
К ним динамически цепляются (и отцепляются) игровые свойства (**component**),
которые представляют собой простые и прозрачные структуры данных.
Вся игровая логика и динамика помещена в обработчики (**system**),
которые манипулируют коллекциями компонентов.
К этим коллекциями зачастую удобно применять
функциональный подход map-reduce.

Сложные иерархии наследования тут вообще не нужны.


### Выводы
Функциональная композиция оказалась наиболее востребована
в самых сложных моих проектах,
и она сильно повлияла на их архитектуру.
Хорошо, что это случилось на стадии проектирования -
не придётся исправлять много кода.

Кое-где, правда, иерархия классов у меня осталась,
и я ещё больше убедился, что это правильное решение.

Во всей иерархии тензоров нет ни одного абстрактного класса:
все классы, включая корневой `Tensor` либо уже используются,
либо будут использоваться с развитием проекта.
Например, арифметические операторы полезны и для тензоров общего вида,
и для матриц, и для гамильтонианов, и для матричных многочленов.
Есть и более сложные функции, которые могут работать
как с родительскими классами, так и с потомками.
Попытка использования композиции в начале проекта
дала куда более громоздкий код, чем нынешняя версия с наследованием.

Классы тестирования теперь проверяют выполнение LSP
(в этом проекте уже были ошибки из-за его нарушения),
поэтому они повторяют дерево наследования тестируемых классов.
Тестовые классы с разных уровней иерархии
тоже передаются в одни и те же функции,
только вызывает их система автоматического тестирования.


## Общие выводы
То, что пишут в книгах по ООП
порой создаёт впечатление искуственных сложностей.
Что-то вроде ачивок:
"вписаться в один из известных патернов проектирования",
"не создавать функций вне классов",
"пройти Half-Life 2 используя ровно одну пулю",
"построить сарай без единого гвоздя"
и т.п.

Для разных случаев подходят разные инструменты,
и функции, в силу их простоты, часто предпочтительнее классов.
Я даже рад, что не очень глубоко погрузился в изучение и использование ООП.
На работе я сперва активно использовал C без классов и привык к функциям.
До сих пор с удовольствием применяю их в первую очередь,
прибегая к наследованию классов только там, где это действительно помогает.
