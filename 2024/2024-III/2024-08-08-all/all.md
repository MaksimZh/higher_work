# Страшное слово в ваших спецификациях

## 1. Страшное слово "всё"
Компьютерные программы очень изменчивы и очень живучи.
Обнаруженные в старых автомобилях недостаки конструкции
просто не переносят в новые изделия.
Даже устойчивые концепции в их "интерфейсе" изменились
с появлением АКПП и электронного стояночного тормоза.
Программные продукты в этом плане более стабильны
со всеми своими недостатками.
Чего только стоит традиция предоставлять приложениям
почти неограниченный доступ к файловой системе.

Проблема в том, что запущенное пользователем приложение
имеет доступ ко **всему**, к чему имеет доступ пользователь.
Ему доступные **все** файлы пользователя,
включая настройки других преложений и личную переписку.
Если же приложение запускается от имени администратора
ради какой-то одной операции,
то ему даются **все** права администратора
на **все** операции во **всей** системе.

В какой-то момент очередной корпоративный антивирус
выводит из строя **все** компьютеры,
начиная с "печатных машинок" и заканчивая медицинским оборудованием,
потому что **все** обновления скачиваются и устанавливаются автоматически,
и установка происходит со **всеми** правами администратора.
А надо-то было скопировать пару файлов и перезапустить пару процессов,
вместо **всей** системы.

Когда-то "всё" означало одно, а теперь - совсем другое.
Если обещали "всё" в спецификации - значит обещали и это "другое",
которое даже представить себе не могли,
а если бы могли - ни за что бы не захотели обещать.

Так что теперь я не хотел бы увидеть это слово
нигде и ни в какой спецификации,
кроме предложений вида
"**запрещено всё**, что не разрешено".


## 2. Практика

### 2.1. В качестве параметров принимаются все хэшируемые объекты
Тензор - многомерный массив,
каждая ось которого имеет уникальный идентификатор
и может иметь набор параметров.
Парметры привязываются к осям в конструкторе тензора:
```Python
tensor = TensorType(data, axis1(param11, param12), axis2(param21, param22))
```

В старой версии спецификации в качестве параметров
принимались все хэшируемые объекты.
Из-за этого каждому типу тензоров нужно было разбираться
с почти произвольным набором входных данных
и большим количеством возможных ошибочных вариантов.
И ещё, в квадратных скобках можно было указывать размерность оси,
либо индекс на ней (в зависимости от контекста).
Эти данные тоже интерпретировались как парметры.

В новой версии требуется, чтобы тип парамета был потомком класса `Parameter`.
Каждый непосредственный потомок этого класса
является слотом под одно необязательное значение.
У каждой оси может быть не более одного параметра в каждом слоте.
Например, для матриц есть слот `MatrixAxis`,
у которого два потомка: `MatrixCol` и `MatrixRow`.
Из-за того, что у оси может быть не более одного параметра типа `MatrixAxis`,
там будет либо столбец, либо строка, либо ни то, ни другое.

Это упрощает обработку парметров, так как они уже сгруппированы,
а ошибки, связанные с множественными значениями, исключены.


### 2.2. Нужно обработать все параметры
В конструкторе тензора его параметры последовательно обрабатываются
классами в цепочке наследования начиная с типа, экземпляр которого создаётся
и до базового `Tensor`.

В старой версии спецификации было требование, чтобы все парметры осей
были обработаны до того, как очередь дойдёт до `Tensor`.
Потом появилась идея, что размеры осей тоже должны быть параметрами,
и это даже казалось логичным.
Трудность в том, что они используются
уже после обработки параметров цепочкой классов.
То есть, размеры осей оказались параметрами,
для которых не годится стандартная логика
"всё должно быть обработано до...".

Позже оказалось, что после извлечения части (сечения) массива,
или арифметических операций,
набор параметров может быть несогласованным,
и их нужно подержать необработанными,
пока не будет явно указан тип результата.

Решением стало разделение "всех" параметров на обязательные
(которые должны быть обработаны),
необязательные (которые можно выкинуть, если не нужны или не согласованы),
готовые (которые точно не выкинем)
и размеры (которые подчиняются своей логике).

Под каждый вид параметров - своя спецификация.


### 2.3. Все параметры переносятся в результат
В старой спецификации было указано, 
что при арифметических операциях или сечении тензора
все параметры осей аргументов переходят в результат.
Это было ошибкой, потому что набор осей у результата может быть таким,
что параметры будут несогласованны.

Например, если при сечении мы берём один столбец из матрицы,
то ось столбцов пропадает, а ось строк остаётся,
хотя по спецификации они всегда должны иметь пару.
Перенос признака оси строк в результат приведёт к ошибке.

Решением стало описанное выше разделение параметров на несколько видов.
После выполнения операции результат имеет базовый тип `Tensor`,
а параметры аргументов переходят в него как *готовые*
(так они и не отбрасываются).
Потом на основе получившегося тензора создаётся новый,
и эти же параметры становятся *необязательными*
(так они ни с чем не конфликтуют),
а те, которые явно указаны в конструкторе - *обязательными*
(так ловятся ошибочные лишние значения).


### 2.4. Все возможные структуры
Один мой студент написал программу, которая, по его заявлению,
могла провести определённые расчёты для всех зависимостей
состава полупроводника от одной координаты.
Программа упала при первом же тесте, который я предложил.

Оказалось, что его "всё" не предполагало самого простого случая -
однородный полупроводник с однородным слоем другого состава внутри.
"Всё" означало гладкие функции, без резких скачков.

Новая версия спецификации была такой:
кусочная полиномиальная зависимость.
Тут сразу понятно что должны представлять из себя входные данные:
коэффициенты этих полиномов для каждого куска.


### 2.5. Доступ ко всей базе параметров
В одном старом проекте часть кода была написана на C++,
а часть - на Tcl.
Для взаимодействия этих двух частей использовалась
одна большая глобальная переменная под названием Parameter Database (PDB),
представляющая собой древовидную структуру данных,
напоминающую реестр Windows.

Требование быть доступной для всего кода сделало эту структуру
самым простым и потому единственным путём взаимодействия разных модулей
и разных потоков.
PDB использовалась для
хранения промежуточных результатов расчётов,
обмена данными между потоками,
скрытой передачи параметров в вызываемые функции...
Из-за этого структура PDB стала очень сложной,
а архитектура проекта - ужасной.

Дальнейшая судьба проекта мне неизвестна.
Сейчас, если бы мне пришлось его сопровождать,
то первой целью стало бы устранение завязки всего кода на одну переменную.
Для промежуточных результатов - списки иммутабельных значений.
Для взаимодействия потоков - сообщения.
Для передачи аргументов - вызовы чистых функций.


## Общие выводы
"Всё" на самом деле всегда означает что-то конкретное,
на чём внимание сфокусировано настолько,
что ничего другого и не видно.
Из-за этого кажется, что что-то - это вообще всё.
Это во многом психологический момент,
который касается не только программирования.

Когда мы говорим "всё запрещено",
часто имеются в виду вполне конкретные сценарии поведения системы,
которые могут быть следствием сбоев или злого умысла.

То есть, нет никакого "всё".
Как только "всё" появилось, нужно сразу его конкретизировать.
В противном случае к нему со временем прилипнут нежелательные добавки,
потому что "всё" у каждого своё, да ещё и меняется со временем.
