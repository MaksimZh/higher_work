# Дефункционализация

## 1. Теория
Понятие функции в математике очень широкое.
Грубо говоря, это произвольное отображение из одного пространства в другое.
При этом есть ряд элементарных функций, которые известны даже школьникам
и присутствуют в стандартной библиотеке большинства языков программирования
(`sin`, `exp`, `log`, ...)
Есть специальные функции,
которые встречаются в относительно небольшом классе задач,
но про которые довольно много информации в специальной литературе
и которые есть в библиотеках для научных и инженерных рассчётов
(функции Бесселя, интеграл Ферми, ...).
Работать с этими хорошо известными функциями куда удобнее,
чем с произвольными отображениями.

С функциями в программировании ситуация аналогичная:
есть произвольный код, который трудно передавать и хранить,
а также опасно выполнять, если источник ненадёжный;
а есть подмножества операций и их комбинаций,
которые можно сериализовать и хранить как данные, а не машинный код.
Простой пример - арифметические выражения,
которые можно представить в виде формулы-строки,
а для стековых машин особенно удобно хранить в постфиксной форме.

Такие данные удобно передавать по сети, потому что,
во-первых, они не привязаны к контексту,
т.е. не имеют указателей на код, доступный только локально.
Там, конечно, тоже используются низкоуровневые функции,
но они хорошо известны и доступны повсеместно
как часть стандартной библиотеки, или данного конкретного проекта.
Это аналогично использованию в математических выражениях
общеизвестных элементарных функций
(или спецфункций в рамках определённой ниши). 

Во-вторых, из-за ограничений на набор действий,
которые может выполнять такая функция,
её использование куда безопаснее, чем в случае произвольного кода.
Просто представьте, что на какой-то онлайн-сервис
для, допустим, решения дифуров,
можно будет загружать DLL с произвольной функцией,
описывающей систему уравнений.
Никто так, конечно, не делает.


## 2. Практика

## 2.1. Поиск по значению
В одном из проектов нужно было привязать
набор параметров к набору элеметнов.
Все элементы разные, иммутабельные и хэшируемые,
а параметры разные в рамках каждого элемента, иммутабельные и хэшируемые.
Поэтому очевидным выбором стала структура данных в виде
словаря, где ключи - это элементы,
а значения - это множества параметров:
```Python
Mapping[Element, Set[Parameter]]
```

Самой частой операцией при работе с этими данными было извлечение параметров
в соответствии с некоторым условием:
```Python
def find(
        data: Mapping[Element, Set[Parameter]],
        condition: Callable[[Parameter], bool],
        ) -> Mapping[Element, Set[Parameter]]:
    ...
```
В качестве condition использовалась произвольная функция,
однако, в 80% случаев это была проверка типа:
```Python
condition = lambda v: isinstance(v, SomeType)
```
а в 20% случаев - проверка значения:
```Python
condition = lambda v: v == some_value
```
Поэтому, я сделал две функции: `find_by_type` и `find_by_value`,
которые принимают, соответственно, тип и значение для поиска.
Это и была **дефункционализация**.

В некоторых случаях требовалось,
чтобы значение имело один тип из некоторого набора,
или чтобы найденное значение было единственным для данного ключа.
Чтобы включить соответствующие проверку сразу в условие поиска
был разработан мини-DSL:
```Python
find(data, if_instance(int) | if_instance(str) & is_single)
```
Фактически, это была **рефункционализация**,
потому что условие поиска было спрятано в метод класса,
экземпляр которого передавался в качестве второго параметра (`condition`),
и сериализация для которого не была предусмотрена.


## 2.2. Оптимизация поиска по типу
По мере развития проекта оказалось,
что возможность привязать к одному элементу несколько параметров одного типа
не просто не нужна, но и нежелательна.
В коде повсеместно встречались условия с `is_single`.
Поиск по значению тоже стал неактуален:
оказалось, что типы-потомки гораздо удобнее для поиска,
а их конкретные значения хорошо подходят
для передачи дополнительной информации.

В итоге, более удобной оказалась структура данных следующего вида:
```Python
Mapping[Type[Parameter], Mapping[Element, Parameter]]
```
Словарь верхнего уровня группирует элементы по корневому типу
(прямой потомок класса `Parameter`).
На уровне ситсемы типов гарантируется, что
у каждого элемента может быть не более одного параметра
каждого корневого типа.
При этом поиск по типу проходит быстрее,
так как сразу вычисляется корневой тип,
и используется только одно значение из словаря верхнего уровня.

Всё, никакой DSL здесь больше не нужен.
Нужна только выборка по типу, или по элементу:
```Python
@overload
def __getitem__(self, key: Type[Parameter]) -> Mapping[K, Parameter]:
    ...
@overload
def __getitem__(self, key: K) -> Set[Parameter]:
    ...
```


## 2.3. Декларация независимости от контекста
В одном из будущих проектов очень пригодится возможность
автоматической дефункционализации.
Большинство функций будут представлены в декларативной форме -
в виде dataflow-графа, где входы и выходы процедур связаны
через иммутабельные (однократно связываемые) узлы данных.
Нет проблем сохранить такой граф в виде соответствующей структуры данных,
для безопасности ограничив набор возможных процедур на уровне системы типов.

Конечно, при сериализации в какой-нибудь JSON и восстановлении
нужно будет проверять, что злые хакеры не подсунули нам лишнего кода.
Однако, когда у нас задан тип данных, код проверки не придётся писать вручную.

Вот так и получится, что произвольный декларативный код
можно будет передавать безопасно и независимо от контекста.
Точнее, он будет передаваться между совместимыми контекстами.


### Выводы по практике
Функции-параметры выглядят как данные,
но это не те данные, которые удобно хранить и передавать
за пределами локальной копии приложения.
В этом смысле они не уникальны,
т.к. есть ещё варианты "неудобных данных",
например, объекты со ссылками на другие объекты.
В общем, всё, что сильно зависит от контекста - это "неудобные данные".

Указатели (ссылки) - это как раз такой неудобный случай,
будь то указатели на данные или на функции.
Их значения нужны для низкоуровневых операций в рантайме
и не имеют смысла на уровне логики программы.
Эти значения меняются от машины к машине и от запуска к запуску,
и поэтому их хранение и передача бессмысленны:
контексты оказываются несовместимы.

Дефункционализация - это способ отвязаться от контекста.
Вместо неизвестного указателя на произвольный код
мы получаем сериализуемую комбинацию "элементарных функций",
которые есть во всех совместимых контекстах.
Это как писать "sin(x)" вместо "число у меня в книжке в таблице в строке 56 и втором столбце".


## Общие выводы
Пока работал с дефункционализацией, выработал у себя привычку
задавать ещё один вопрос по поводу кода, который я пишу:
"**а что если этот аргумент нужно будет сохранить в файл**
**или передать удалённо?**"
Может тогда не стоит городить тонны ссылок?
Или эти ссылки можно обернуть во внешнюю структуру данных
(в связанных списках и графах они же никому не мешают)?
Я бы назвал процесс ликвидации (инкапсуляции) ссылок "дереференсизацией".

А данная конкретная функция -
это функция как элемент внутренней логики программы?
Тогда нет проблем - пусть передаётся в качестве аргумента,
всё равно внутренняя логика хранится внутри исполянемого файла
и наружу не лезет.
А если это внешняя логика, которая в какой-то момент
может оказаться частью запроса от клиента к серверу?

Есть ощущение, что умеренная дефункционализация (и дереференсизация)
делает программу только лучше,
потому что при этом уменьшается связность компонентов.
Глобальную (в масштабах приложения) связность лучше вообще минимизировать:
может то, что сейчас выглядит как вызывающая и вызываемая процедуры,
через пару лет окажется клиентом и сервером в разных странах.
