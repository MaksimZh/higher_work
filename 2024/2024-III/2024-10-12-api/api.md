# Долгосрочное проектирование API

## 1. Теория
Чем API меньше, тем меньше в нём возможностей
для плохих решений и устаревания.
Поэтому особенно важно, чтобы клиентский код
имел необходимый минимум информации
о структурах данных и функциях библиотеки.
Например, имена и типы полей структуры - это часть интерфейса,
а их размер и расположение в памяти - нет.
Тем не менее, кто-то может написать код,
который полагается на эту низкоуровневую информацию
и поломается при её изменении.

Как избежать зависимости клиентского кода от недокументированных параметров?
Нужно испортить возможность их использования
в отладочной и/или тестовой версии.
В случае со структурой - переставить поля, добавить между ними пустые и т.п. 
Тогда при тестировании программа упадёт,
и сразу станет очевидно, что она залезла не туда.

Конечно, сложно предусмотреть все возможности
неправильного использования модуля или библиотеки,
но можно защититься от наиболее вероятных.
Языки типа C развивают привычку копаться в байтах памяти,
вместо использования абстрактных переменных и структур,
и многие программисты ещё застали ограничение в 64кб и стремятся к экономии.
Всё это нужно учитывать.


## 2. Практика

### 2.1. Тензор - не массив
Основная задача тензоров - удобство работы с осями многомерных массивов.
Не нужно запоминать, какой номер индекса у производной,
позиции на координатной сетке, коэффициентов многочлена и т.п.
Что же будет, если действовать по старинке,
полагаясь на конкретное расположение данных в памяти?
Тогда его нужно синхронизировать в разных местах программы,
или в разных программах.

Чтобы этого избежать, у тензоров порядок осей принципиально не фиксирован.
Набор осей - это неупорядоченное множество,
а доступ данных возможен только через функцию распаковки,
которая требует явно указать желаемый порядок осей.

Конечно, в Python ничего не скроешь, но есть надежда,
что никто не будет писать такое:
```Python
getattr(getattr(tensor, "__container"), "__data")
```
вместо положенного по спецификации:
```Python
tensor.unpack(a, b, c)
```


### 2.2. Вершинный буфер
В современном OpenGL можно хранить в памяти видеокарты
произвольную информацию для рисования,
например, пространственные и текстурные координаты для точек.
Важно только привязать нужные позиции в памяти к параметрам шейдеров.
В результате получается, что расположение данных задаётся
при определении структуры данных,
а потом, в другом месте программы, та же информация
передаётся драйверу видеокарты в виде "магических чисел".

Что с этим делать?
Нужно максимально исключить низкоуровневую информацию из оборота,
её должна инкапсулировать структура данных вершины.
Эта структура должна либо сама регистрировать все смещения в OpenGL,
либо предоставлять для этого информацию.
В идеале (многие языки программирования такое позволяют)
хорошо бы получать размер структуры и смещения полей автоматически.
Тогда можно было бы использовать приём с перемешиванием полей
в отладочной версии.


### 2.3. Тип как состояние
В том же OpenGL полно сценариев, где нужно последовательно вызывать функции
в строго определённом порядке, иначе работать не будет,
например:
```F#
let texture = GL.GenTexture()
GL.ActiveTexture(TextureUnit.Texture0)
GL.BindTexture(TextureTarget.Texture2D, texture)
```
У этих функций есть нерабочие комбинации, например:
```F#
let texture = GL.GenTexture()
GL.BindTexture(TextureTarget.Texture2D, texture)
GL.ActiveTexture(TextureUnit.Texture0)
```
Тут мы привязываем текстуру к том, не знаю чему,
потому что активная не задана вовсе, либо задана где-то,
и не факт, что это та, которая нам нужна.

А вот так уже не получится:
```F#
GL.ActiveTexture(TextureUnit.Texture0)
GL.BindTexture(TextureTarget.Texture2D, texture)
let texture = GL.GenTexture()
```
Функция `BindTexture` требует второй аргумент, которого на момент вызова нету.

При неверном использовании API вначале может везти с внутренним состоянием,
но при обновлении ОС или драйверов всё поломается.
Чтобы этого избежать, нужно передавать состояние по цепочке функций
как аргумент.
Тогда правильный порядок будет обеспечен на этапе статического анализа:
```F#
let texture = GL.GenTexture()
let atGL: ATGL = GL.ActiveTexture(TextureUnit.Texture0)
atGL.BindTexture(TextureTarget.Texture2D, texture)
```
Метод `BindTexture` есть только у типа ATGL.

В идеале, хорошо бы обеспечить невозможность "ветвить" состояние OpenGL
с помощью некоторого аналога монады `IO` в Haskell.


### Выводы
Чем больше низкоуровневых вещей использует программа,
тем больше вероятность устаревания важной информации.
Стандарт OpenGL обновляется куда чаще, чем вечные математеческие истины
вроде произведений типов (которыми являются кортежи и структуры).
Для устойчивости API лучше использовать более высокие абстракции:
структуры вместо смещений,
перечисления вместо индексов,
абстрактные типы данных вместо конкретных.


## Общие выводы
В контексте темы долгосрочного API,
сложность со структурами в C возникает из-за того,
что мы в принципе имеем доступ к указателям и сырой памяти.
Поэтому велик соблазн всё это использовать напрямую,
не утруждая себя "лишними" абстракциями и обёртками.
Так можно и в Rust использовать `unsafe` и обмануть borrow checker,
а точнее самих себя.

В идеале, более высокие абстракции должны быть защищены
от такого "грязного" низкоуровневого кода.
Тогда не нужно будет в отладочной версии
подкладывать ему свинью в виде перемешанных полей структуры.
Хорошо бы на уровне системы типов разделить данные на свои и чужие,
а потом запретить всякие `unsafe` для чужих данных.
Тогда вся магия с памятью будет локализована (инкапсулирована)
внутри отдельного класса (модуля, библиотеки),
и API не пострадает.
Пока я о таких возможностях на уровне статического анализа не слышал.