# Компромисс между возможностями и удобством

## 1. Теория
Понятно почему профессиональные редакторы всего чего угодно
(видео, рисунки, 3D модели)
выглядят как пульт управления АЭС.
Чем больше возможностей, тем больше всяких кнопочек,
а чем больше кнопочек, тем проще в них запутаться,
особенно новичку.
В программировании то же самое - более продвинутые библиотеки
имеют больше всяких настроечных параметров.
Тот же Vulkan - это куча сущностей и настроечные структуры с десятками полей.

К счастью, в программировании есть и большие возможности
по обёртыванию этих всех сложностей в удобный интерфейс
для типовых сценариев использования.
Графические движки для игр делают именно это,
фактически, позволяя "разговаривать" с видеокартой
на более простом языке.
У интерфейса некоторых программ также есть pro-mode и light-mode.
Тогда пользователь может сделать выбор -
ограничить число доступных сущностей ради удобства,
или же опуститься на более низкий уровень абстракции
и настроить всё под специфическую задачу.

Общем случае, при накоплении определённого количества возможностей
среди них появляется возможность перехода на новый уровень абстракции
с большим удобством и меньшими возможностями.


## 2. Примеры

### 2.1. Апгрейд до Python 3.12
В одном из моих проектов
с помощью нового синтаксиса для дженериков
удалось разбить сложный кусок кода на несколько простых модулей.
Каждый из них реализует один из аспектов системы
и имеет лаконичный и удобный интерфейс.
В основном модуле весь этот функционал соединяется
с помощью множественного наследования.

Понятно, что в Python такая возможность была изначально.
Просто без поддержки со стороны системы типов делать такие вещи неудобно,
потому что легко незаметно сделать ошибку и потом долго отлаживать код.
Теперь же появились возможности для статического анализа.


### 2.2. Автоматическая сборка параметров тензоров
Есть базовый класс `Tensor`,
при помощи которого очень удобно работать с размерностями (осями)
многомерных массивов.
У него есть наследники, которые добавляют к массиву дополнительную информацию
на основе параметров, которые передаются в конструктор.

В класс `Tensor` была добавлена возможность
извлечения этих дополнительных параметров прямо из описания осей массива
и передачи их классам-наследникам.
В результате, во-первых, стало гораздо удобнее передавать эти параметры,
поскольку логически они привязаны как раз к осям, а не массиву в целом.
Во-вторых, пропала необходимость
переопределять конструктор в классах-наследниках,
в результате чего некоторые из них превратились в пустые классы,
комбинирующие возможности родителей с помощью множественного наследования.
Создание наследников стало гораздо удобнее.


### 2.3. Арифметика тензоров
В том же проекте наследование базового класса `Tensor`
от волшебного `numpy.lib.mixins.NDArrayOperatorsMixin`
и определение всего одного метода добавило возможность
применять к тензорам и всем классам-потомкам
массу математических операций и функций.
Применение этих операций сразу к тензорам без преобразования в массивы
местами сократило код в десятки раз.


### 2.4. Сохранение параметров
Поскольку комбинирование потомков `Tensor` разных типов
создаёт неопределённость типа результата и потенциально
может нарушить некоторые инварианты для параметров осей,
результат этих операций - всегда базовый класс `Tensor`.
С другой стороны, такие проблемы возникают далеко не всегда,
и вручную перенастраивать все параметры результата очень неудобно.

Для решения этой проблемы параметры аргументов сохраняются
в результате согласно чёткой спецификации (это устраняет неопределённость).
Это делает возможным автоматический апгрейд от `Tensor`
к любому классу-потомку с использованием сохранённых параметров.
Возможность их частичной перенастройки также имеется.

Так применение математических операций к специальным тензорам стало удобнее.


### 2.5. Плагины для транслятора
Этот проект ещё далёк от реализации,
так что, пока, только теория.
Программа представляется в виде графа,
состоящего из модулей, у которых есть слоты для подключения
связей от других модулей.
Сами модули внутри тоже могут содержать такой графический код.

Транслятор сначала преобразует граф к некоторому промежуточному формату,
который затем удобно транслировать уже на целевой язык программирования,
или же сразу в двоичный код.
Возможности транслятора ограничивают тот набор абстракций,
который можно использовать в программе.
Например, есть вариант модули - функции и связи - передача данных,
а хочется: модули - акторы и связи - потоки сообщений.

В "традиционных" языках программирования это решается
с помощью всяких препроцессоров и автоматической генерации кода.
В новом проекте можно поступить радикально:
сторонние библиотеки могут содержать не только модули,
но и код для трансляции этих модулей (и их комбинаций)
в код понятный транслятору и другим библиотекам. 
Получаются, что возможности транслятора
можно будет расширять с помощью плагинов.


## Общие выводы
На примере тензоров особенно хорошо видно,
что новые возможности создают неудобства:
то с параметрами нужно разбираться,
то переупаковку тензоров добавлять.
Приятно то, что борьба за удобство не сокращает возможности,
а только обёртывает их в более удобный интерфейс.

Теоретически, у такого сокрытия неудобств есть предел,
если возможности конкретного языка программирования зафиксировать.
Если же и они развиваются, как в примере 2.1 с апгрейдом Python,
то предел отодвигается.
А ещё можно этот предел снять, как в примере 2.5 с плагинами для транслятора.
Тогда появляется гораздо больше возможностей
как сделать разработку очень удобной,
так и радикально всё запутать, породив множество несовместимых диалектов.
