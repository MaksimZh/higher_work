# Применяем функциональную композицию правильно

# 1. Теория
Следуя "классическому" ООП подходу,
если нам нужно посчитать зарплату работника с учётом премий,
то следует наплодить кучу наследуемых классов.
Как минимум нужен класс для расчёта зарплаты, класс для расчёта премии,
родительский класс абстрактного рассчёта
и ещё один класс-потомок - для комбинирования абстрактных рассчётов.
Ух!

А если это ещё и Java с требованием размещать каждый класс в отдельном файле,
то для работы с таким кодом желательно иметь 2-3 дополнительных монитора.

Это всё при том, что в подавляющем большинстве
современных языков программирования большая часть этих "классов" уже есть.
Для вычислений можно использовать функции,
а для их комбинирования - композицию функций.
С помощью лямбда-выражений код можно сделать достаточно компактным,
наглядными и легко модифицируемым.

По сути, на уровне логики и тот и другой код эквивалентны.
Просто в первом случае логические элементы `вычисление` и `комбинация`
отображаются в не совсем удачные элементы кода - классы,
и для того, чтобы их правильно соединить,
появляется необходимость в наследовании.
Функции тут подходят куда лучше прежде всего из-за синтаксического сахара:
компилятор сделает большую часть работы сам, без ручного создания классов
и их искусственных иерархий.

Другой вариант "лишнего" наследования - повторное использование кода.
С учётом требований LSP и потенциальных обновлений кода,
родительский класс может принести с собой гораздо больше,
чем хотелось бы.
Куда лучше ограничить его влияние на новый код,
используя обёртку вокруг ограниченного подмножества API.


# 2. Практика

## 2.1. Сделай сам
Есть постоянно расширяющаяся иерархия классов,
в которой хочется автоматически запускать юниттесты родителей для потомков.
Для этого класс с тестами родителя
наследуется и дополняется тестами для потомка.

Тесты предполагают создание экземпляров классов, и сложность в том,
что этот процесс не подчиняется LSP.
То есть, аргументы конструктора,
которые подходят для создания экземпляра родительского класса,
могут быть некорректны для некоторых классов-потомков.
Например, абстрактный тензор может иметь любой ранг,
хоть нулевой (это будет скаляр),
а матрица рассеяния, по определению, должна иметь хотя бы два измерения.

Чтобы корректно запускать тесты для нетривиальных потомков,
класс родителя содержит поле `sample`,
которое задаёт минимальный корректный экземпляр тестируемого класса.
Родительский тест анализирует это поле и создаёт класс `SampleData`
с информацией для создания и проверки других тестовых экземпляров.

Трудность в том, что иерархия многоуровневая,
и для класса нужно запускать тесты
не только родителя, но и "дедушки" с "прадедушкой".
Для тестирования на дополнительных уровнях
может понадобиться дополнительная вспомогательная информация,
и в результате понадобится иерархия ещё и для `SampleData`.

Решение вот какое - поместить всю информацию для тестирования 
в тестовые классы.