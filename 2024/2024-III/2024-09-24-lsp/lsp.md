# Когда наследование лучше композиции?

## 1. Теория
У меня всегда было ощущение, что наследование создаёт слишком сильную связь
и для подтипирования,
и для повторного использования кода,
и для расширения поведения.
Возможно дело LSP в том, что оно делает сразу все три эти вещи,
и велики шансы, что минимум с одной из них что-то пойдёт не по плану.
Классический пример с классом `Квадрат`, который "портит" спецификацию
родительского класса `Прямоугольник` -
это случай нарушения подтипирования из-за переопределения поведения.
Здесь возможность, предназначенная для расширения,
использована не по назначению.
Вероятно, подтипирование портится чаще других аспектов наследования,
потому что (насколько мне известно)
никак не защищено на уровне статического анализа кода.

Принцип подстановки Лисков, который вытекает из определения подтипа,
как раз призван защитить подтипирование.
Пока инструменты для статической проверки корректности кода
недостаточно развиты,
оптимальным вариантом является динамическая проверка
соответствия классов-потомков спецификации родителя
с помощью автоматических тестов.


## 2. Использование LSP в тестах

## 2.1. Je suis `Tensor`
Раньше я не тестировал классы-потомки на соответствие LSP.
После изучения данного материала начал внедрять эту практику
в своём главном рабочем проекте.

Тесты базового класса `Tensor` расположены в отдельном модуле:
```Python
class _BaseTensorTests(TensorTest):

    sample: Tensor = Tensor(0)
    
    ...

    def test_init_1d(self):
        self.skip_if_dim_above(1)
        T = type(self.sample)
        source = self.gen_source(1)
        tensor = T(source.data, source.patterns)
        self.assertEqual(tensor.ndim, 1)
        self.assertEqual(tensor.axes, set(source.axes))
        self.assertEqual(tensor.sizes, source.sizes)
        self.assertEqual(tensor.params, source.params)
        np.testing.assert_array_equal(
            tensor.unpack(source.axes),
            source.data, strict=True)
    
    ...

# Avoiding autodetection of the base test class if imported
class TestWrap:
    Base = _BaseTensorTests
```

А вот так они активируются:
```Python
from tests.test_tensor.base import *
...
class Test_Tensor(TestWrap.Base):
    pass
```

Ключевую роль здесь играет поле `sample` -
это образец, который задаёт прежде всего тип тестируемого тензора.
Например, при тестировании матриц это поле имеет соответствующее значение:
```Python
class Test_MatrixTensor(TestWrap.Base):

    sample = MatrixTensor(0)
    
    ...
```

Есть тензоры, которые нельзя создать из скаляров,
потому что там должен быть минимальный набор данных и минимальный ранг.
Например, у многочлена должна быть ось степеней,
а у матрицы рассеяния - две оси для входящих и выходящих волн.
Тогда поле `sample` выглядит по-другому:
```Python
class Test_MatrixPoly(TestWrap.Base):

    sample = MatrixPoly([0, 0], pow_axis)

    ...
```
В случе с многочленами будут пропущены все тесты класса `Tensor`,
которые работают с 0-мерными объектами (скалярами).


## 2.2. Второй уровень
А ведь `MatrixPoly` - потомок `MatrixTensor`,
а `SquareMatrixPoly` - потомок `SquareMatrixTensor` и `MatrixPoly`.
Интересно, что `SquareMatrixTensor` - это потомок `MatrixTensor`,
так что `SquareMatrixPoly` - это два раза `MatrixTensor`.

В общем, нужно ещё делать базовый тест для `MatrixTensor`,
и для `SquareMatrixTensor`, и для `MatrixPoly`.
Работы - непочатый край.
Тут напрашивается выделение в отдельную абстракцию операции прогонки
родительских тестов.


### Выводы по использованию LSP в тестах
Для автоматического тестирования потомков калсса `Tensor`
на соответствие спецификации родителя пришлось сильно усложнить тесты.
Прежде всего это связано с тем, что для создания некоторых потомков
требуется особый минимальный набор осей с определёнными параметрами.
Этот набор задаётся в поле `sample`, и часть тестов,
которые неприменимы к нему, просто пропускаются.

Здесь может возникнуть вопрос:
а не нарушают ли LSP более жёсткие требования к конструктору?
Я считаю, что нет, потому что конструктор - это про создание объекта,
а не про его поведение.

Например, если сделать тип `FileName` потомком класса `String`,
то все операции со строками будут применимы,
ведь их результат не обязан иметь тип `FileName`
и удовлетворять всем сопутствующим ограничениям.
Если же встроить в конструктор этого типа проверку на то,
что используются только допустимые символы, то это никак не повредить
"строковости" результата.
Наоборот, это даёт уверенность в том, что это допустимое имя файла
уже на уровне кода (при статическом анализе).


## 3. Наследование <=> полиморфизм подтипов

### 3.1. Матрицы - это тензоры
В коде выше класс `Tensor` - вполне рабочий тип,
который может использоваться для облегчения работы
с произвольными многомерными массивами, если от них не требуется ничего
за пределами стандартного набора операций из NumPy.
Его потомок - `MatrixTensor` - полезен
когда у нас есть выделенные пары осей столбец-строка.
В классических матрицах такая пара одна,
но в задачах квантовой механики бывает полезно иметь 3-4 пары, например,
если решение раскладывается последовательно по нескольким базисам,
и нет смысла терять данные, запихивая их в одну размерность.

В первой версии я использовал композицию `Matrix` содержит `Tensor`,
и это было очень неудобно.
Очень часто для матриц требуются общие "тензорные" операции,
и пробрасывать их все во внутренне поле - это куча лишней работы.
Наследование здесь сработало идеально.


### 3.2. Гамильтониан - это зонная матрица с базисами
В моём проекте (и в диссертации :)) гамильтониан - это матрица операторов.
Для хранения информации об операторах используются
отдельные оси с базисами.
Например, в трёхмерной задаче это базис `1,x,y,z`,
а в одномерной - `1,x`.

То есть, нужно комбинировать свойства матриц и тензоров с базисами.
Благодаря множественному наследованию это делается элементарно:
```Python
class Hamiltonian(BandMatrixTensor, BasisTensor):
    pass
```
Важно, что в проекте существуют сущности обоих родительских типов,
и для работы с ними есть специальные функции.
Поэтому важно, чтобы `Hamiltonian` можно было использовать
и как `BandMatrixTensor`, и как `MatrixTensor`, и как `BasisTensor`.
Сколько лишнего кода понадобилось бы в случае композиции!


### 3.3. Окно избыточных возможностей
Начал осваивать рисование через OpenTK (обёртка OpenGL в .NET) в F#,
а там стандартное:
```FSharp
type Window(width, height, title) =
    inherit GameWindow(...)
    ...
    override this.OnLoad (): unit = 
        base.OnLoad()
        ...
    ...
```
Наследование от стандартного типа окна я вижу ещё со времён Delphi 5
и мне всегда казалось, что здесь есть избыток свободы.
Через родительский класс окна мы получаем слишком много доступа
к внутренностями библиотеки GUI и возможность что-то поломать.
Здесь, например, можно забыть вызвать родительский `OnLoad`,
или вызвать его не в том месте,
а потом долго искать ошибку, связанную с ожиданиями создателей
`GameWindow` о том, где вызывается родительский метод
(хорошо, если эти ожидания документированы).

Моё окно - это не окно вовсе, а целая программа, раскиданная по
перегрузкам обработчиков событий, и от этого некомфортно.
Поэтому мне бы хотелось оставить окно отдельной сущностью,
с которой можно обмениваться сообщениями и командами рисования.


### Выводы по наследованию и полиморфизму
Если предполагается использовать класс-потомок наравне с родительским
в каких-то функциях, то наследование - наиболее удобный путь.
Проброс всего интерфейса родителя при композиции -
это трудоёмкий путь, чреватый ошибками.

Отдельным плюсом могут стать
алгоритмы обработки множественного наследования.
В Python, например, это удобный способ комбинировать
поведение разных классов в одном.
В этом случае особенно важно защищать ожидаемое поведение родителя
и тестировать его, иначе это комбинирование может привести
к проблемам.

Что касается наследования от окна,
то здесь проблема прежде всего на уровне логики.
Программа - это не окно, но её расчленяют и втискивают в методы окна.
Получается, что формально у нас окно - подтип базового окна,
и всё в порядке.
А по сути, у нас программа - подтип окна
(устройства ввода-вывода, если угодно), и это странно.


## Общие выводы
После этой работы стал увереннее использовать наследование там,
где оно хорошо подходит.
Прошло стремление везде пихать композицию, потому что это "правильно".

Особенно ценными оказались мысли по поводу наследования окон.
Получается, что формально правильная с точки зрения кода система типов
может быть уродливой на уровне логики.
Окна уже давно превратились из средства взаимодействия с пользователем
в средство организации кода, и это не очень хорошо.

Я возлагаю большие надежды на распространение функционального
программирования, которое с окнами как раз не очень совместимо.
При правильном подходе это должно привести к тому,
что функциональный код вытеснит работу с состоянием GUI
за пределы логического ядра программы.
Сам попробую это сделать в своём проекте по работе с графикой.
