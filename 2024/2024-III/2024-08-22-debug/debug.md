# Отладка как наука

## 1. Теория
Универсальная техника сборки кубика Рубика, как ни странно,
в первую очередь основана не на том, чтобы двигать элементы,
а на том, чтобы сделать их неподвижными.
Центры граней итак неподвижны,
а на первом шаге вокруг одного из них собирается крест
из кубиков на рёбрах, которые ставятся в нужную позицию
и далее остаются неподвижными.
Затем очередь доходит до угловых кубиков этой грани и т. д.
Под неподвижностью здесь подразумевается "инвариант",
который должен сохраняться до и после очередной комбинации поворотов.
Внутри комбинации может твориться что угодно.

На каждом этапе увеличивается количество неподвижных элементов,
а головоломка имеет конечный размер,
и потому неизбежно сходится к решению.
Такая стратегия куда продуктивнее наивных попыток угадать комбинацию,
которая поставит все элементы на свои места.

При отладке программы можно попытаться угадать причину ошибки,
но это как играть в лотерею.
В случае удачи мы сразу попадём в цель,
но при промахе практически к ней не приблизимся,
а шансы промаха весьма высоки.
Поэтому лучшей стратегией будет последовательно
исключать целые классы возможных причин ошибки,
задавая вопросы, ответ на которые может сказать,
что точно **не** является причиной ошибки.
После этого "непричину" можно оставить "неподвижной"
и заняться чем-то другим,
последовательно приближаясь к цели.


## 2. Практика

### 2.1. Задача о стелющемся кубе
В школе в рамках дополнительных занятий по программированию
я решал следующую задачу.
Нужно было вывести на экран проекцию каркаса куба,
которая вращается вокруг некоторого центра.
У меня вместо вращения куб вёл себя очень странно:
он деформировался, как будто стелился по "земле"
и в итоге выстилался в один горизонтальный отрезок.

Я уже не помню нашёл ли я ошибку в программе,
или же отчаялся и просто переписал всё с нуля.
Сейчас первый вопрос, который хочется задать:
"Правильно ли вычисляются новые координаты при повороте?"
Этот вопрос недостаточно общий, ведь ошибку в расчётах можно долго искать,
но она может быть вовсе не в повороте.
Лучше такой:
"При вычислении новых координат данной вершины
используются координаты других вершин?"
Если нет, то задача о повороте куба сводится к задаче о повороте вектора,
которая куда проще отлаживается.
Если да, то ошибка может быть как раз в логике взаимодействующих вершин,
но там будет уже следующий вопрос.


### 2.2. Задача о безвыходной программе
В университете, когда мы осваивали язык C,
мне удалось написать программу, которая запускалась,
выдавала правильный результат,
а при выходе гарантированно падала с сообщением "segmentation fault".
С помощью преподавателя удалось найти причину:
выход за границы массива,
перезапись заголовка соседнего блока выделенной динамической памяти
и ошибка при освобождении этой памяти функцией `free`.
Ошибка была вовсе не в том месте программы, где она падала.

То, что ошибка проявляется при вызове функции `free`
я выяснил довольно быстро.
Тут нужно было задать правильный вопрос:
"Входные данные функции `free` корректны?"
Ответ очевиден - "нет", вряд ли ошибка в стандартной библиотеке языка C.

Тогда второй вопрос:
"Моя программа способна нарушить инварианты `malloc`/`free`?".
А вот тут ответ "да", потому что от переменных в C одно название,
память никак не защищена.

Следующий вопрос:
"Моя программа меняет значения указателей?"
Ответ - "нет", это в коде несложно проверить.
Значит портится служебная информация, которая мне не должна быть доступна.

Способ её испортить тут очевиден - отсюда следующий вопрос:
"Программа меняет только ту память, которая ей выделена?"
Ответ - "нет".
Достаточно было проверить арифметику указателей,
и ошибка нашлась.


### 2.3. Задача о бесконечном потоке
Обычно в полупроводнике зона проводимости и валентная зона
по энергии не пересекаются.
Если же приложить электрическое поле, то пересекаются,
но в пространстве они отделены барьером, который для частиц непроницаем
(пока мы его не пробьём слишком высоким напряжением, конечно).
Мне удалось придумать структуру, где этот барьер прозрачен,
и электрон может свободно перейти из валентной зоны в зону проводимости,
а в валентной зоне останется дырка.
Задача была в том, чтобы решить уравнение движения для электрона
и доказать, что этот переход возможен.

Результаты расчётов были очень странными.
Казалось, что они противоречат закону сохранения материи,
как будто один электрон налетает на барьер,
отражается три, а насквозь проходят два. 
Попытка найти ошибку в расчётах успехом не увенчалась,
потому что она была во входных данных,
и даже не в самих данных, а в их интерпретации.

Правильный вопрос такой:
"Действительно ли результат расчётов противоречит закону сохранения материи?",
а точнее: "Нарушена ли непрерывность плотности потока вероятности?"
Отличная формулировка, потому что плотность потока можно посчитать
независимо от основного кода, это что-то вроде контрольной суммы.
Оказалось, что она непрерывна, то есть, ответ - "нет".

На основе этого результата, и того,
что расчёты писались по TDD и были покрыты тестами,
можно утверждать, что задача верно решена в соответствии со входными данными.
Тогда вопрос: "Входные данные корректны?"

А вот тут снова плотность потока.
У корректных входных данных поток должен быть направлен слева направо,
а тут ответ - "нет", он направлен справа налево.
В валентной зоне импульс и скорость частицы
направлены в противоположные стороны,
потому что
"If you aren’t confused by quantum mechanics,
you haven’t really understood it"
(Нильс Бор).

Получается, что входные данные говорят не "один электрон прилетел",
а "один электрон отразился".
А ответ говорит не "три отразилось, два прошло",
а "три прилетело, два прошло".
Падение было перепутано с отражением.


### Выводы по практике
Когда думал над этими примерами поймал внутреннее сопротивление 
правильным общим вопросам,
которые ведут к решению по самому короткому пути.
Так и хочется поскорее "выиграть в лотерею" -
сразу угадать где ошибка и всё исправить.
Похожее чувство мешает сначала написать спецификацию и тесты.


## Общие выводы
Похоже, что существует глобальная психологическая проблема:
всё хочется сделать побыстрее, даже если это чревато риском ошибок.
Это касается далеко не только программирования и отладки,
поэтому иногда перед поворотом приходится тормозить и за себя,
и за того, кто в этот момент тебя обгоняет.

Есть два способа мышления: один направлен на быстрый результат,
а второй - на поиск оптимальной стратегии.
Важно применять их правильно, и в разработке, очевидно,
нужен именно второй.
