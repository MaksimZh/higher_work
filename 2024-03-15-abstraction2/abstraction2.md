# Что такое абстракция

## 2. Абстракции в коде

### 2.1. Оси массивов и тензоров
Измерения многомерных массивов в NumPy называются осями.
Эти оси обладают номерами **для конкретного массива**
и в них не вкладывается никакого другого смысла.
В моём проекте оси - это уникальные сущности,
**не привязанные к конкретному тензору**.

Оси массива, который лежит внутри тензора,
отображаются на оси тензора.
Это прямо в коде есть, вот:
```Python
class SimpleTensor[A: BaseAxis]:
    __array: NDArray[Any]
    __axis_indices: dict[A, int]

    def __init__(...):
        ...
        self.__axis_indices = {ax: i for i, ax in enumerate(axes)}
```
Для осей доступен набор математических операций,
на которые отображаются функции из NumPy.
Например, слияние NumPy-осей при `reshape`
становится умножением тензорных осей,
`transpose` соответствует перестановке тензорных осей,
`newaxis` - это унарный плюс.
В планах на новую версию есть реализация ещё пары операций.

В результате, вместо пачки `reshape`, `transpose` и `newaxis`
с непонятными индексами и размерами
```Python
foo.transpose(1, 0, 2).reshape(-1, 2 * DIM)[..., np.newaxis]
```
пишется что-то вроде
```Python
foo.unwrap(k_axis, deriv_axis * band_axis, +layer_axis)
```


### 2.2. Математика для осей
Из неизданного (пока не пошло в `master`).

В предыдущей абстракции было две части.
Первое - отображение номеров осей в оси-сущности.
Мы как-бы помечаем оси массива осями тензора,
и перестановка немых номеров превращается в перестановку
символов с понятным смыслом (про это подробнее будет в пункте 2.3).

Вторая часть - отображение более сложных операций с осями массивов
в математические операции с осями тензоров.
Эту абстракцию удалось отделить от осей и оформить в виде отдельного модуля.
Вот, например, операция слияния (`*`):
```Python
class Merged[T](RepackSource):
    ...
    
    def __mul__[V](self, other: "Merged[V]") -> "Merged[T | V]":
        ...


class Mergeable:
    ...
    
    def __mul__[A: "Mergeable", B: "Mergeable"](
            self: A, other: B | Merged[B]) -> "Merged[A | B]":
        ...
    
    
    def __rmul__[A: "Mergeable", B: "Mergeable"](
            self: A, other: Merged[B]) -> "Merged[A | B]":
        ...
```
А вот и новая операция - преобразование (`>>`):
```Python
class Repack[S, D]:
    
    def __init__(self, source: S, dest: D) -> None:
        ...
    
    ...


class RepackSource:
    
    def __rshift__[S, D](self: S, other: D) -> Repack[S, D]:
        return Repack(self, other)
```
В коде для слияния видно, что его результат (`Merged`)
может быть исходным объектом для преобразования (`RepackSource`).
Это достигается с помощью наследования.

В конце модуля есть вот такой класс:
```Python
class Combo(Mergeable, RepackSource):
    
    def __getitem__[T](self: T, arg: Any) -> Sliced[T]:
        return Sliced(self, arg)

    def __pos__[T](self: T) -> Added[T]:
        return Added(self)
    
    def __neg__[T](self: T) -> Dropped[T]:
        return Dropped(self)
    
    def __invert__[T](self: T) -> Ensured[T]:
        return Ensured(self)
```
Что бы мы не унаследовали от `Combo`,
к нему сразу подключаются все математические операции.
Это классический миксин.

**Комбинирование сущностей** в определённые структуры
вроде `Merged` и `Dropped`
**отображается в математические операции**
вроде `*` и `-`.
Это свойство вынесено в отдельный компонент, который совершенно не зависит
от того, что именно мы комбинируем!
При этом нам ещё и доступна статическая проверка типов!


### 2.3. Предметная область и тензорные оси 
Зайдём с другой стороны.
Оси массивов обладают определённым смыслом в предметной области,
но в коде этот смысл сложно сохранить,
потому что всё превращается в индексы.
С тензорными осями ситуация иная.
Мы можем дать оси осмысленное имя и использовать его для доступа к данным.
Сейчас это доступно только для двух операций -
преобразования массива в тензор и обратно:
```Python
class Tensor(SimpleTensor[Axis]):
    ...
    
    def __init__(self, array: NDArray[Any], *patterns: AxisPatternArg):
        ...
```
```Python
class SimpleTensor[A: BaseAxis]:
    ...
    
    @final
    def unwrap(self, *patterns: NestIter[AxisPattern[A]]) -> NDArray[Any]:
        ...
```

Абстракция здесь состоит в том, что
**критерии группировки данных** из предметной области
**отображаются в тензорные оси** в программе,
и в коде выше эти оси используются именно для группировки данных.
При этом данные будут обрабатываться одинаково для всех тензоров,
где есть соответствующая ось,
не зависимо от того, как именно они расположены в памяти.
Это строгое правило избавляет от путаницы с индексами.


### 2.4. Типы осей
В предметной области есть взаимоисключающие характеристики осей:
например, это либо строка, либо столбец в матрице.
С другими характеристиками, например, признаком того,
что ось нумерует решения уравнения, сочетаются и столбцы и строки.
А ещё ось может вовсе не обладать ни одной из этих характеристик.

Отсюда появляется следующая абстракция -
**характеристики осей** (предметная область)
**отображаются в типы осей**:
```Python
class MatrixAxis(AxisKind):
    ...

@final
class MatrixCol(MatrixAxis):
    ...

@final
class MatrixRow(MatrixAxis):
    ...
```
```Python
class WaveAxis(AxisKind):
    ...

@final
class SolAxis(WaveAxis):
    ...

@final
class CompAxis(WaveAxis):
    ...
```
Правила комбинирования характеристик
отображаются в иерархию классов-типов.
Нельзя задать две характеристики, у которых есть общий предок
помимо `AxisKind`.

Отдельный уровень в иерархии тензоров добавляет ряд операций
для работы с типами осей:
```Python
class AxisKindTensor(Tensor):
    ...

    @property
    def root_kinds(self) -> set[Type[AxisKind]]:
        ...
    
    @property
    def kind_axes(self) -> set[Axis]:
        ...
  
    def axis_kinds(self, axis: Axis) -> set[Type[AxisKind]]:
        ...
    
    def axis_kind_clusters(
            self, axis: Axis) -> dict[Type[AxisKind], AxisCluster]:
        ...

    def axes_of_kind(self, kind: Type[AxisKind]) -> set[Axis]:
        ...
    
    def axis_clusters_of_kind(
            self, kind: Type[AxisKind]) -> dict[Axis, AxisCluster]:
        ...

    def kind_trees(
            self, kind: Type[AxisKind]
            ) -> dict[AxisCluster, set[Axis] | AxisKindTrees]:
        ...
```
То есть абстракция типов осей выделена в коде явно
и собрана в отдельном модуле.


### 2.5. Параметризация осей
Типы осей задаются с помощью другой абстракции - параметров осей.
Дополнительная информация об осях тензора отображается в параметры осей.
При этом существует протокол обработки этой информации
на всех уровнях иерархии тензоров.
В старых версиях он поддерживался только на уровне спецификации,
но теперь - на уровне кода:
```Python
class Tensor(SimpleTensor[Axis]):
    __params: AxisParams

    ...

    def __prepare_params(self, params: AxisParams) -> PreparedAxisParams:
        tmp_params = PreparedAxisParams(ready=AxisParams(), rest=params)
        for t in _call_chain(type(self), "prepare_params"):
            assert issubclass(t, Tensor)
            t_params = t.prepare_params(tmp_params.rest)
            tmp_params = PreparedAxisParams(
                ready = tmp_params.ready << t_params.ready,
                rest = t_params.rest)
        return tmp_params


    @staticmethod
    def prepare_params(params: AxisParams) -> PreparedAxisParams:
        ...    
    
    def __post_init(self):
        for t in reversed(_call_chain(type(self), "post_init")):
            assert issubclass(t, Tensor)
            t.post_init(self)
    
    
    def post_init(self):
        ...
```
Есть гарантии, что параметры будут обработаны разными классами
из иерархии тензоров в определённом порядке.


### Выводы по работе с кодом
Все перечисленные абстракции присутствуют в коде
в виде типов, методов и их комбинаций.
Я интуитивно старался сделать их более явными
и разместить в отдельных модулях.
В какой-то момент я понял, что нужно стремиться
сделать каждую абстракцию независимым компонентом,
а затем собирать их вместе.
Пока хорошо получилось сделать это с математическими выражениями для осей.


## 3. Определение Дейкстры
> Мы хотим открыть для себя новый семантический уровень мышления,
> на котором мы парадоксально можем быть абсолютно точны --
> ещё более точны, чем даже на уровне синтаксиса кода.

Я понимаю это так, что программа на уровне логики
составляется из математических объектов,
т.е. таких сущностей, свойства которых могут быть формализованы
на языке математики.
В конце концов, математика - это наиболее точный из доступных нам языков
описания реальности.
Во-вторых, нужно стремиться комбинировать эти математические объекты
и отображать эти комбинации в новые объекты так,
чтобы была возможность формального описания более объёмных и сложных программ
с помощью ограниченного объёма формул.

Частью такого подхода является создание и использование универсальных АТД
с чётким набором операций: списков, множеств, функций и т.д.
Их комбинирование должно быть максимально простым,
например - через агрегацию и наследование,
что позволит легко доказать корректность комбинации.
В конечном счёте, для предметной области
нужен свой математический язык, который максимально к ней близок,
и при этом напрямую отображается в программный код.


## Общие выводы
Я ещё больше укрепился в своём стремлении
максимально явно выражать абстракции в коде
и выделять их в независимые компоненты.
В идеале, программа должна состоять из множества независимых модулей,
которые собираются вместе в ключевых точках с помощью простых операций.
Пусть пока автоматическая формальная верификация кода не очень распространена,
но это хороший задел на будущее -
комбинирование должно быть простым, чтобы его было просто проверить.
Если требуется сложная комбинация - она должна быть выделена
в отдельную абстракцию и протестирована независимо.
Наследование классов, например, внутри устроено нетривиально,
но у него есть чёткая спецификация и проверенная реализация,
поэтому такая операция считается простой.

Отрадно, что аннотации типов в Python явно двигаются в нужную мне сторону.
Пункт 2.2. был бы невозможен до выхода Python 3.12.
