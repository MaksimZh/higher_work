# Рефакторинг

# 1. Массивы и тензоры
Библиотека NumPy очень хороша для вычислений, когда речь идёт об одномерных
(максимум - двумерных) массивах.
Работа с многомерными наборами данных, где разные размерности
(в терминах NumPy - "оси"/"axes")
обладают существенно разным смыслом в предметной области,
приводит к появлению страшных конструкций:
```Python
# [meshes, mesh, initials*origins*components]
y1 = np.array([
    integrate.solve_ivp(odeFunc, (t[0], t[-1]), y0, t_eval = t).y.T \
        for t in meshes])
# [meshes, mesh, initials, origins, components]
y2 = y1.reshape(len(meshes), meshes.shape[1], len(initials), len(origins), dim)
# [initials, origins, meshes, mesh, components]
y = y2.transpose(2, 3, 0, 1, 4)
```
Для манипуляций с осями был добавлен новый слой абстракции - тензоры.
Задача тензоров - предостатвить более удобный интерфейс по сравнению с
`reshape`, `transpose` и `newaxis`:
```Python
# интерпретируем первые две оси как meshes и r
# а третью ось разбиваем на три оси заданного размера
# (размер указывается в квадратных скобках)
tensor = Tensor(
    y1,
    ax_meshes,
    ax_r,
    ax_init[len(initials)] * ax_orig[len(origins)] * ax_comp[dim])
# создаём массив NumPy с заданным порядком осей для дальнейших вычислений
y = tensor.get_array(ax_init, ax_orig, ax_mesh, ax_r, ax_comp)
```
Вот пример с `newaxis`:
```Python
>>> a = np.arange(1, 4)
>>> a[np.newaxis] + 10 * a[:, np.newaxis]
array([[11, 12, 13], 
       [21, 22, 23], 
       [31, 32, 33]])
>>> Tensor(a, x).get_array(+y, x) + Tensor(10*a, y).get_array(y, +x)
array([[11, 12, 13],
       [21, 22, 23],
       [31, 32, 33]])
```

Массивы - это наборы данных для математических операций, которые используются
на самом низком уровне абстракции.
На более высоком уровне абстракции за логическую структуру данных отвечают тензоры.
То есть здесь введена новая граница для разделения на уровни абстракции.

В рамках данного проекта все непосредственные операции с осями массивов NumPy
(`reshape`, `transpose` и `newaxis`) запрещены по соглашению
(на уровне документации).
В коде (на уровне интерфейсов и типов) явного запрета нет.

В дальнейшем возможно расширение возможностей тензоров и вытеснение зависимости
от NumPy из всё большего количества модулей и уровней логики.


# 2. Классификация осей
Пусть мы получили массив линейно-независимых решений
системы дифференциальных уравнений
и хотим использовать метод матрицы рассеяния для вычисления их правильной
линейной комбинации.
На уровне логики это два разных раздела предметной области.

При решении системы дифуров достаточно различить независимые решения.
Для построения матриц рассеяния важно различать ещё и направления распространения.
Грубо говоря, добавляется дополнительная ось размерности 2 с координатами "лево"/"право".

[Раньше предлагалось](../2023-08-01-protective/protective.md)
различать оси по их типу с помощью *льготного наследования*.
При этом получается, что при переносе данных на новый этап расчётов нужно
поменять их оси, т.к. в разных разделах предметной области свои типы осей.
