# Раздутость кода

## 1. Выводы по изучению материала
Каждый раз, когда я соприкасаюсь с достаточно низкоуровневым API
(будь то WinAPI, GSL, DirectX или Vulkan)
всегда возникает неприятное ощущение от большого количества структур,
в которых нужно заполнять кучу параметров.
Как вариант, также встречаются функции с огромным количеством аргументов.
В самих структурах и функциях нет ничего плохого, конечно.
Раздражают меня параметры - флаги, когда нужно указать, что я имю в виду,
передавая те или иные данные, и какие данные я передаю.

После изучения данного материала я могу сформулировать,
что именно меня раздражает в таких схемах -
наличие неявных абстракций.
Это связь между параметрами и командами на уровне логики,
нарушения которой не отслеживаются при статическом анализе (на уровне типов),
но больно бьют при выполнении программы.
Сюда относятся все проблемы, которые возникают из-за того,
что функции вызваны не с теми аргументами, не в том порядке,
не в том состоянии глобального контекста и т.п.
При этом программа вполне нормально компилируется и запускается,
только делает не то, что нужно.
Самый яркий пример такого поведения -
последствия ручного управления памятью в C.

Если есть формальные требования к поведению какой-то системы,
то лучше один раз автоматизировать их выполнение,
чем каждый раз думать и (неизбежно) иногда ошибаться.
Мы же создавали компьютеры как раз для автоматизации, правда?

## 2. Работа с кодом

### 2.1 Обработанные и необработанные параметры тензоров
Самый яркий пример из старой версии моего проекта,
где обрабатываются параметры тензора:
```Python
@staticmethod
def prepare_params(
        uid: int, param_axes: tuple[ParamAxis, ...]
        ) -> tuple[ParamAxis, ...]:
    mx_params, clean_param_axes = _extract_mx_params(param_axes)
    mx_data = _process_mx_params(_UniqueMatrixGroupKey(uid, 0), mx_params)
    new_param_axes = tuple(
        pax(**{_DATA_PARAM_NAME: mx_data[pax.axis]})
        if pax.axis in mx_data else pax
        for pax in clean_param_axes)
    return new_param_axes
```
Функции `_extract_mx_params` и `_process_mx_params` весят по 30 строк.

Нужно помнить, что под именем `_DATA_PARAM_NAME` хранятся обработанные
параметры.
При этом они сейчас обработанные, а при переносе осей тензора вместе с их
параметрами в другой тензор, они уже снова не обработанные.
Как тут не запутаться?

Этот код упрощался в два этапа.
Первое - явное разделение обработанных и не обработанных параметров
на уровне метода `prepare_params`, а не на уровне их хранилища
(хранение и обработка - логически разные аспекты в данном проекте!).
```Python
@staticmethod
def prepare_params(params: AxisParams) -> PreparedAxisParams:
    links, rest1 = params.extract_by_type(_LinkRow)
    cols, rest = rest1.extract_by_value(COL)
    row_targets = {
        row: assume_single(ln).target
        for row, ln in links.items()}
    target_cols = set(row_targets.values())
    assert target_cols <= cols
    assert len(target_cols) == len(row_targets)
    new_matrix_params = AxisParams(
        (row(ROW(col)), col(COL(col)))
        for row, col in row_targets.items()) << \
        AxisParams(col(COL) for col in cols - target_cols)
    return PreparedAxisParams(
        ready = AxisParams(),
        rest = rest << new_matrix_params)
```
Это весь метод, нет вызовов функций по 30 строк!
Одна из причин такого сокращения кода - появление типа `PreparedAxisParams`,
где есть поля `ready` и `rest`.
Логика, которая следит за их обработкой, теперь находится в базовом классе,
и она общая для всех тензоров:
```Python
def __prepare_params(self, params: AxisParams) -> PreparedAxisParams:
    tmp_params = PreparedAxisParams(ready=AxisParams(), rest=params)
    for t in _call_chain(type(self), "prepare_params"):
        assert issubclass(t, Tensor)
        t_params = t.prepare_params(tmp_params.rest)
        tmp_params = PreparedAxisParams(
            ready = tmp_params.ready << t_params.ready,
            rest = t_params.rest)
    return tmp_params
```


### 2.2 Группировка осей тензора
Другой момент - в старой версии была логика группировки осей,
которая характерна и для матриц (строки/столбцы),
и для волн (решения/компоненты)
и для квантовомеханических операторов (импульс/зона).
Каждый раз эта логика управлялась "вручную".

В очень старой версии была попытка решить вопрос за счёт типов осей,
но это создало трудности.
Логика группировки принадлежит тензорам, а не осям.
Ось может быть общей для двух разных тензоров, и для волн это решение,
а для оператора - зона, ну и какого типа должна быть сама ось?

В новой версии группировка была перенесена в отдельный класс `AxisKindTensor`,
который выполняет ей автоматически на основе типов данных.
Теперь это не типы осей, а типы параметров, которые к осям привязаны.
Вот как работает разделение на строки и столбцы:
```Python
class MatrixAxis(AxisKind):
    def __call__(self, cluster: AxisCluster) -> Self:
        return type(self)(cluster)

@final
class MatrixCol(MatrixAxis):
    pass

@final
class MatrixRow(MatrixAxis):
    def __rshift__(self, other: Axis) -> "_LinkRow":
        assert self.cluster is None
        return _LinkRow(other)
```
К каждой оси можно привязать только один такой параметр,
и это обязательно должен быть экземпляр `final` класса, -
это всё отслеживается автоматически.
Группировка строк и столбцов уже работает "из коробки",
нужно только преобразовать эти данные в "матричный" формат:
```Python
self.__matrix_clusters = {
    MatrixCluster(
        frozenset(value[MatrixCol]),
        frozenset(value[MatrixRow]))
    for value in self.kind_trees(MatrixAxis).values()}
```
Вот благодаря этому код "сдувается" пример на 50 строк в каждом модуле.
Эти 50 строк теперь спрятаны и протестированы ровно в одном месте.


### 2.3 `uid` не нужен
Раньше этот параметр таскали с собой все тензоры,
а нужен он был только матрицам (позже - классу `AxisKindTensor`).
Оси одного вида (`AxisKind`) делились на группы по значениям ключа,
которые хотелось сделать уникальными для разных экземпляров
тензоров одного типа.

Есть ещё одна вещь, которая уникальна для каждого экземпляра -
для него ровно один раз вызывается метод `prepare_params`
класса `AxisKindTensor`.
Чтобы локализовать логику, связанную с уникальными сущностями,
ключи нужно генерировать автоматически внутри этого метода:
```Python
unique = object()
new_cluster_map = {
    root: {c: _ClusterKey(unique, i) for i, c in enumerate(clusters)}
    for root, clusters in cluster_map.items()}
```
Это один метод для всех классов-потомков.
Параметр `uid` больше не нужен, как и код для его обработки.


### Выводы
Код упрощался в нескольких модулях в три этапа.
Все эти этапы объединяет одно общее свойство - собирание размазанной логики
со всего проекта и локализация в одном базовом классе.
Для обработанных и необработанных параметров (2.1) - в классе `Tensor`,
для группировки осей по типам (2.2) и ключам (2.3) -
в классе `AxisKindTensor`.
Можно сказать, что эти логические концепции
проявились в виде сущностей на уровне кода
(`PreparedAxisParams`, `AxisKind`, `_ClusterKey`)
и так стали доступны для автоматизации.


## Общие выводы
Парадокс: чтобы "сдуть" код, нужно добавить в него сущности!

Да, это так работает!
Если всё сделать правильно, то эти новые сущности "всасывают" в себя
код из остальных мест программы.
Что значит сделать правильно?
Сущность должна существовать на уровне логики,
тогда она неизбежно проникает в код,
потому что за соблюдением логики приходится следить.

Самый простой вариант - повторяющийся код, который можно перенести в функцию.
Тогда все вызовы функции будут обращаться к одному и тому же коду, который
можно написать и протестировать ровно в одном месте.

Другой пример - данные, которые передаются и обрабатываются вместе,
можно собрать в отдельный АТД.
Там ещё можно и проверку инвариантов явно прописать.

В любом случае, проявление логических концепций в коде полезно делать
осознанным, управляемым и локализованным.
Тогда можно "переложить ответственность" за отслеживание этой логики
с человека на компьютер.
