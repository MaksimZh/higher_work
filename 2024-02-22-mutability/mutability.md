# Мутабельность как упрощение модели данных

## 1. Рефлексия по теории
В школе и университете с данными всё было просто -
приходилось работать максимум с массивами чисел.
В настоящих, промышленных задачах больше думаешь про данные,
чем про алгоритмы.
В своём рабочем проекте уже не первый месяц вылизываю модель данных,
и грядёт очередная ревизия базовой иерархии классов,
ибо опять я по неопытности зашёл не туда.
Благо - код пока только мой и такие глубокие изменения возможны.

Раз уж решения о структурах данных так сложны,
может возникать необходимость менять эти решения,
а значит желательно максимально отвязать программу
от конкретных структур данных.
Тут хорошо помогает полиморфизм и абстрактные интерфейсы.
Если брать конкретно Python, то пусть функции и методы лучше работают
с `Mapping` вместо `dict`, с `Sequence` вместо `list` и т. д.


## 2. Работа с кодом
Раньше моя библиотека для работы с тензорами была простой.
Там был только класс `Axis` для обозначения осей тензоров,
и класс `Tensor` для хранения данных.
И вот захотелось мне особенных тензоров,
которые знают какая ось у них строка, а какая - столбец матрицы.
Класс `Matrix` как наследник `Tensor` создать было нетрудно,
но вот для указания типа оси создавать новый класс-наследник для `Axis` -
это перебор.
Менять сам класс `Axis` тоже не хотелось,
потому что он активно используется внутри тензора,
в том числе и как ключ словарей,
поэтому его лучше оставить максимально простым.

Тогда и было принято решение передавать и хранить тип оси в `Matrix`
в отдельном словаре.
Получалось, что тип оси - не часть самой оси.
Это казалось странным и усложняло структуру данных
из-за необходимости таскать с собой ещё и словарь.
Потом оказалось, что это было правильное решение,
потому что в *предметной области* тип оси относится не к оси,
а к контексту её использования, то есть - к тензору.
То, что для одной матрицы столбец, для другой может быть строкой.

С появлением более сложных тензоров, например, матриц рассеяния,
которые отличают оси направлений от всех остальных,
стало нужно привязывать к осям ещё больше параметров.
Так оказалось, что множество возможных параметров осей -
это величина расширяемая с развитием проекта.
Тогда для класса `Axis` пришлось всё-таки делать иерархию:

  - базовый `BaseAxis` формирует DSL для комбинирования осей;
  - наследник `Axis` - хэшируемый и простой,
    для различения осей массивов и поиска параметров по ключу;
  - `ParamAxis` - брат `Axis` - расширяет DSL возможностью
    привязывать к осям произвольные параметры.

Вот и получается, что сохранение простого `Axis`
и использование его как ключа в более сложных хранилищах
в целом упрощает модель данных за счёт "разделения труда"
вместо запихивания кучи функций в один класс.
А ещё такую модель данных проще расширять.


### Рефлексия по работе с кодом
Такой взгляд издалека на проект со стороны структур данных
наводит на ряд мыслей по поводу глубоких улучшений.
Есть базовая система тензор-оси и базовый DSL для манипуляции с осями.
Поверх неё строится система параметров для осей и DSL расширяется.
Далее хочется ввести систему, аналогичную сечениям массивов,
которя также требует расширения DSL осей.
Затем нужна будет система поддержки арифметических операций.
И сечения и арифметика будут менять и структуру осей и их параметры.

В итоге, нужна возможность расширять ядро системы, меняя DSL осей,
так, чтобы не приходилось переписывать периферию.
Здесь нужно учитывать, что активная работа с осями идёт именно в ядре,
а с их параметрами - на периферии.
То есть, желательно максимально развязать эти две подсистемы
с помощью абстракций и полиморфизма.


## Рефлексия

