# 1. Размеры осей
Следующий код интерпретирует одномерный массив как тензор ранга 2
размерности 4 на 4:
```Python
t = Operator(
    np.arange(10, 10 + 4 * 4),
    k_left(k_basis_1xyz)[4] * k_right(k_basis_1xyz)[4])
```
При этом к каждой из осей привязывается базис из 4-х элементов.

Для того, чтобы не указывать размер явно в таких случаях
было решено объединить механизмы привязки произвольных данных к осям
и механизм задания размера.

Раньше оператор `()` создавал на основе оси объект класса `TagAxis`,
а оператор `[]` - `SizeAxis`:
```Python
class Axis:
    ...
    
    def __getitem__(self, size: int) -> "SizeAxis":
        return SizeAxis(self, size)
    
    def __call__(self, tag: Any) -> "TagAxis":
        return TagAxis(self, tag)
```
Теперь оператор `[]` создаёт объект `TagAxis` с тегом специального типа `SizeTag`:
```Python
class Axis:
    ...
    
    def __getitem__(self, size: int) -> "TagAxis":
        return TagAxis(self, SizeTag(size))

    def __call__(self, tag: Any) -> "TagAxis":
        return TagAxis(self, tag)

...

@final
class SizeTag:
    ...

    @property
    def size(self) -> int:
        return self.__size
```
Особое внимание стоит уделить свойству `SizeTag.size`.
Такое же свойство есть у любого базиса:
```Python
class Basis(ABC):

    @abstractproperty
    def size(self) -> int:
        assert False
```
Код, который отвечает за разбиение осей, может получить размер из любого тега,
который обладает этим свойством.
Теперь не нужно дублировать информацию о размере оси в базисе
и в квадратных скобках.

Для этого изменения было решено отказаться от сложной системы типов,
которая обеспечивала статическую проверку правильного указания размерностей.
Это позволило сделать автоматическое определение размерностей более гибким:
считывать их из базисов и считать одинаковыми для всех осей, где они не указаны:
```Python
t = Tensor(np.arange(3 * (2**3) * 5), a[3] * b * c * d * e[5]) # 3 x 2 x 2 x 2 x 5
```


# 2. Изменение иерархии осей
В предыдущем примере объекты класса `TagAxis` могли хранить по одному тегу.
При этом, поскольку `TagAxis` был потомком `Axis`, можно было вкладывать
объекты `TagAxis` друг в друга.
В результате, для извлечения размера оси нужно было использовать рекурсивный
поиск:
```Python
def _parse_size(axis: Axis) -> tuple[Axis, Optional[int]]:
    if not isinstance(axis, TagAxis):
        return axis, None
    a, s = _parse_size(axis.axis)
    if not isinstance(axis.tag, HasSize):
        return TagAxis(a, axis.tag), s
    assert s is None
    if isinstance(axis.tag, SizeTag):
        return a, axis.tag.size
    return TagAxis(a, axis.tag), axis.tag.size
```
В целом, то, что `Axis` был базовым классом приводило к тому, что постоянно
требовалась проверка: является ли данный объект осью, или содержит теги.

Изменение состоит в том, что `Axis` и `TagAxis` становятся разными потомками
приватного абстрактного класса `_BaseAxis`.
При этом `TagAxis` содержит чистый `Axis`, теги в виде множества и размер,
если он задан:
```Python
@final
class TagAxis(_BaseAxis):
    ...

    @property
    def axis(self) -> Axis: ...

    @property
    def size(self) -> Optional[int]: ...
    
    @property
    def tags(self) -> set[Any]: ...
```
Все тензоры работают только с чистыми `Axis` и множествами тегов.
Объекты `TagAxis` используются только в конструкторах тензоров
и особых функциях, которые манипулируют с осями.
Ради этих особых функций пришлось сделать `TagAxis` публичным,
иначе можно было бы и его сделать приватным.


# Резюме
Эти два этапа изменения кода, отвечающего за оси, заняли много времени.
Этот код фундаментальный, и время, потраченное на приведение его в порядок,
потом сэкономит гораздо больше часов при разработке других частей приложения.

На этапе 2. большинство классов, отвечающих за работу с осями,
были сделаны приватными.
Это снизило связность между модулями приложения
и позволило сильно упростить код тестов.

Отказ от сложной системы хранения данных с вложенными `TagAxis` сильно
уменьшил объём кода, зависящего от этого класса.
Следующим логичным шагом будет сделать публичной
только приведённую выше часть интерфейса `TagAxis`,
но эта мысль пришла только при написании этих строк и пока не реализована.
