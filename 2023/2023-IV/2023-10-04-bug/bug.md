# 1. Баг

## 1.1
Опечатка в гамильтониане Кейна, который представляет собой четырёхмерный массив
размерности 8x8x4x4.
Решение - не задавать массив явно, а генерировать с помощью специальных формул
на основе относительно простого набора параметров.
В этом случае опечатка ломает массив во многих местах и её легче обнаружить.

## 1.2
Перепутать в двумерном массиве доступ по (x, y) - (столбец, строка)
и по (i, j) - (строка, столбец).
Одна из моих характерных ошибок, которая встречается почти в каждом проекте.


# 2. Другая плохая вещь

## 2.1
Один из классов содержал внутри ассоциативный массив и предоставлял методы
для проверки наличия ключа и получения значения по ключу.
Вызов второго метода приводил к ошибке, если ключа не было в массиве.
Получалось, что помимо основной функции класс брал на себя часть
работы ассоциативного массива.
Решением стало выдавать весь массив по запросу.

## 2.2
В одной библиотеке для работы с многомерными массивами
индексы в квадратных скобках использовали row-major order,
а в круглых - column-major order.
Это нарушение привычной семантики:
круглые - функция, или что-то похожее, но точно не индекс;
квадратные - индекс, или что-то похожее, но точно не функция.
Теперь всё что угодно может быть индексом и чтение кода требует больше ресурсов.


# 3. Сбивает людей с толку

## 3.1
Индекс, связанный с `row_axis` в тензоре - это индекс в строке (номер столбца),
или индекс (номер) строки?
Сам уже путаюсь. К сожалению, другой терминологии пока не нашёл.

## 3.2
Слово `dimension` в `XArray` - это размерность как `axis` в `NumPy`,
или размерность, как размер?
Наверное поэтом в `NumPy` этого слова избегают, а `XArray` я больше не пользуюсь.


# 4. Хрупкость

## 4.1
Множественное наследование работало без проблем:
```Python
class SymmetricBasisTensor(BasisTensor, SymmetricMatrixTensor):
    ...

class BandOperator(MatrixTensor, BasisTensor):
    ...
```
А потом оказалось, что из-за разного порядка предков в этих двух классах,
от них обоих одновременно наследоваться нельзя (а надо):
```Python
class BandHamiltonian(BandOperator, SymmetricBasisTensor):
    ...
```
Поскольку `SymmetricMatrixTensor` - потомок `MatrixTensor`,
Python не мог определить в каком порядке искать методы:
сначала в `BasisTensor`, а потом в `MatrixTensor`,
как в `SymmetricBasisTensor`,
или наоборот, как в `BandOperator`.

Ошибка в одном модуле, но проявляется совершенно в другом и неделю спустя
при развитии проекта.


## 4.2
При работе с тензорами некоторые оси интерпретируются особым образом,
и для этого используется три механизма: тип, базис, другие теги.
Кое-где одновременнои используется по два механизма,
то есть можно сломать программу каким-то изощрённым способом,
забыв правильно передать данные для одного из них.

Всё-таки использовать тип данных для передачи информации было плохой идеей.
Лучше будет запретить наследование от класса `Axis` и оставить только теги.
Базисы уже являются тегами, так что остаётся только один механизм.


# 5. Побуждает делать что-то опасное

## 5.1
В старой версии моей программы код
```Python
MatrixTensor.wrap(src, x(row=y), y)
```
означал, что `x` - столбец, а `y` - это парная ему строка.
Фактически, столбец обозначался словом `row`.

Новый интерфейс:
```Python
MatrixTensor.wrap(src, x(foo=COL), y(foo=ROW))
```


## 5.2
Из справки по библиотеке XArray:

> Do not try to assign values when using any of the
> indexing methods `isel` or `sel`

> Assigning values with the chained indexing
> using `.sel` or `.isel` fails silently

Это не работает как привычные за 50 лет индексы, но называется индексами.
А ещё оно уже несколько лет **"fails silently"**, потому что кому-то
лень нормально переопределить метод `__setitem__`.


# Резюме
Ошибкой является не только то, что сразу приводит к неправильному результату.
Это и то, что провоцирует появление новых ошибок, и то, что усложняет
защиту от них.
По мене моего обучения в Высшей Школе Программирования для меня акценты
всё больше смещаются в сторону надёжности и возможности повторного использования
кода.
Даже появляются мысли заменить Python на какой-то язык
со статической типизацией.

Коллеги считают, что я трачу много времени на "второстепенные" вещи,
но я не вижу другого способа обеспечить правильность сложных расчётов
с учётом всех возможных и неизбежных изменений в модели.
Для удобной и безопасной работы с многомерными массивами пришлось отказаться
от библиотеки XArray, которая, видимо, создавалась для каких-то других целей.
После их очередного обновления я так и не смог заставить работать старую версию
своей программы.
Просто не понятно что именно сломалось и как это починить.
Не хотелось бы, чтобы моя библиотека обладала похожими свойствами
по отношению к скриптам для расчётов.
