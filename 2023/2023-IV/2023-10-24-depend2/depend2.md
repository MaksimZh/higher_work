# Избавляемся от зависимости от зависимостей-2

## Выводы после изучения материалов
Во-первых, интересно было узнать, что
зависимость определяется не для всего компонента, а для его отдельных свойств.
Для небольших систем это не так очевидно и важно, но для крупных проектов
думание в терминах свойств, а не компонентов, может отразиться
и на архитектурных решениях.
Например, можно добавить возможность динамически отключать
не очень важные свойства с ненадёжными зависимостями
для стабильной работы всего компонента.

Во-вторых, пространство допустимых изменений (ПДИ) - это очень важный элемент
для зависимости.
Если это модуль нашей программы, который мы контролируем, то можно сузить
ПДИ, и часть зависимостей сразу пропадает.
Если важна безопасность, а компонент внешний, то нужно предполагать, что
ПДИ максимально широко, вплоть до умышленного причинения вреда системе через
эту зависимость.


## 1. Зависимость старой расчётной программы от LAPACK
Старая программа написана на языке D и при сборке
статически компонуется с библиотекой LAPACK.


### 1.1 Семантика

#### 1.1.1 Зависимость сборки
Программа не соберётся без библиотеки линейной алгебры,
потому что ей нужна функция для диагонализации симметричных комплексных матриц.
Однако, эта зависимость локализована в одном модуле, и есть возможность
переключения на другую библиотеку.
Я этой возможностью пользовался и уже не помню, собран ли экзешник,
который лежит у меня на компьютере, с LAPACK или Intel MKL.

#### 1.1.2 Зависимость времени выполнения
Диагонализация матриц - ключевой момент расчёта, который выполняется
при каждом запуске несколько (тысяч) раз,
если программа не упадёт раньше из-за некорректных параметров командной строки.

Поэтому я и выбрал статическую сборку, чтобы студенты не забывали
взять с собой библиотеку линейной алгебры при копировании программы.

#### 1.1.2 Функциональные требования
На уровне логики есть зависимость от библиотеки линейной алгебры.
Семантически она локализована, но на уровне функциональных требований она
распространяется на всю программу.
В этой версии программы нет "запасного" алгоритма для решения задачи.


### 1.2 Характеристики
**Быстродействие** программы зависит от быстродействия
библиотеки линейной алгебры на 50-99% процентов
(при разных сценариях использования).
**Стабильность** и **точность**, конечно, тоже,
но в этом плане у меня проблем ни разу не возникало.
В моей практике не было случая, чтобы LAPACK или Intel MKL упали,
или выдали неверный результат при корректных входных данных.


### 1.3 Допустимые изменения
Пока в библиотеке не меняется интерфейс функции для диагонализации симметричной
комплексной матрицы, моя программа не требует изменений.
То есть, программа не зависит от реализации этой функции.

"Диагонализация симметричной комплексной матрицы" - это строгое математическое
определение.
Фактически - это спецификация, которая и задаёт область допустимых изменений.
Если в библиотеке есть функция, которая ей удовлетворяет,
то эту библиотеку можно подключить вместо LAPACK через небольшую обёртку.


## 2. Зависимость расчётной программы от NumPy
Массивы NumPy используются повсеместно на ряду с базовыми типами данных.


### 2.1 Семантика

#### 2.1.1 Зависимость сборки
NumPy используется везде.
Не будет NumPy - даже линтер будет ругаться.


#### 2.1.2 Зависимость времени выполнения
Импорт библиотеки происходит при интерпретации программы,
и здесь возникает зависимость от её наличия.
В коде очень много вызовов функций из этой библиотеки -
это зависимость от интерфейса.


#### 2.1.2 Функциональные требования
Нужны инструменты для работы с многомерными массивами, а также
обращения и диагонализации матриц.
Есть сильная зависимость на уровне логики.


### 2.2 Характеристики
**Быстродействие** программы определяется быстродействие NumPy.
Именно поэтому программа на Python может на равных конкурировать
со старой версией на D.
**Стабильность** и **точность** столь же важны, но здесь проблем не возникало.


### 2.3 Допустимые изменения
Есть привязка к интерфейсу многомерных массивов и функций,
которые используются для их обработки.

Допустимы изменения, которые не меняют интерфейс.
Можно потерпеть изменения, которые меняют интерфейс функций для
работы с матрицами, потому что они используются точечно.
Изменения в интерфейсе создания многомерных массивов - почти катастрофа
(придётся править все модули).


## 3. Зависимость программы от модуля `tensor`
Этот модуль - более удобный интерфейс для reshape и transpose из NumPy.


### 3.1 Семантика

#### 3.1.1 Зависимость сборки
Тензоры есть везде в программе.
Почти все типы данных - класс Tensor, или его потомки.


#### 3.1.2 Зависимость времени выполнения
Почти все данные для расчётов хранятся в тензорах.
Если нужен алгоритм из NumPy, то сначала распаковываются исходные данные
(вызывается метод `Tensor.unwrap`), а затем результаты упаковываются
(вызывается конструктор `Tensor`).


#### 3.1.2 Функциональные требования
На уровне логики тензоры - полезная абстракция над многомерными массивами.
Они позволяют работать с осями массивов как с отдельными сущностями.
Поэтому большая часть логики программы построена в терминах тензорах и осей.
Здесь зависимость очень сильная.


### 3.2 Характеристики
**Быстродействие** не очень важно при аккуратном использовании тензоров
(не создавать новые объекты слишком часто).

**Стабильность** критически важна, и здесь надёжность определяется системой
автоматических тестов.


### 3.3 Допустимые изменения
Интерфейсы механизмов комбинирования осей,
передачи дополнительной информации об осях,
а также создания и распаковки тензоров лучше не трогать.
Спецификация тут довольно большая и задана в юниттестах.

Внутреннюю реализацию можно менять не затрагивая остальной код программы.
Конечно, при этом модуль не должен падать при корректных
(с точки зрения спецификации) операциях.


## 4. Зависимость программы от класса - произведения осей
Этот класс возникает в результате умножения осей оператором `*`.

### 4.1 Семантика

#### 4.1.1 Зависимость сборки
Этот класс (`_AxisMerge`) возникает внутри модуля `tensor`
и используется только там.
За пределами этого модуля `_AxisMerge` можно получить только оператором `*`
и использовать как аргумент для ряда функций.
При этом не предполагается ни вызов конструктора этого класса,
ни обращение к его методам.
В интерфейсе функций он фигурирует неявно,
как элемент алгебраической суммы типов.

Эта зависимость локализована внутри модуля `tensor`.


#### 4.1.2 Зависимость времени выполнения
При преобразовании тензоров высокого ранга в матрицы (тензоры ранга 2)
постоянно используется произведение осей и создаются объекты класса
`_AxisMerge`.
Здесь сильная зависимость.


#### 4.1.2 Функциональные требования
Это вспомогательный класс, который на уровне логики почти не проявлен.
Есть абстракция объединения осей в одну и разделения одной оси на несколько.
Её можно реализовать и другим способом, хотя выделение сущности
"произведение осей", которая хранит сами оси и их порядок,
выглядит наиболее естественно.


### 4.2 Характеристики
**Быстродействие** не очень важно, если не комбинировать оси слишком часто.

**Стабильность** критична и виляет на всю программу.


### 4.3 Допустимые изменения
Можно делать всё, что угодно, даже убрать этот класс.
Лишь бы выполнялась спецификация:
  - при создании тензора произведение осей означает разбиение одной оси
    исходного массива на множители;
  - при распаковке тензора произведение осей означает объединение
    осей-множителей в одну ось массива-результата.


## Выводы по примерам
Очень сложно было выделить именно свойства компонентов.
Удалось сделать это только для характеристик.
Возможно, это потому, что в расчётных программах не так много свойств помимо
выдачи правильного результата вычислений.

Практически везде зависимость времени выполнения максимально жёсткая,
поскольку мои программы не предусматривают динамического переключения
на другие компоненты.

Наиболее сильная семантическая зависимость сборки между модулями внутри
программы.
В случае NumPy, правда, она столь же сильна.
Это отчасти сделана намеренно, поскольку без NumPy с научными расчётами
в Python делать нечего, так что эта библиотека для меня де-факто - стандартная,
почти часть языка.

В общем случае, такая сильная зависимость от нестандартной библиотеки
нежелательна.
В идеале, лучше всё обернуть тензорами.
