# Избавляемся от зависимости от зависимостей

## 1. Зависимость фреймворка
Очередное обновление библиотеки XArray привело к тому, что моя программа
перестала запускаться.
Более того, я не смог починить поломку, потому что там слишком многое зависело
от этой библиотеки и пришлось бы менять структуру данных, которая пронизывала
все модули (про АТД я на момент написания той программы ещё не знал).

Решением было использовать свой АТД для хранения многомерных массивов и
дополнительной информации к ним.
XArray стал мне не нужен, потому что если уж всё равно делать обёртку,
то сразу вокруг более стабильного и простого NumPy.


## 2. Зависимость расшаренного формата
В старых версиях моих расчётных программ я сохранял промежуточные результаты
в текстовых файлах, и формат часто менялся.

В новых версиях я использую HDF5, где можно записать дополнительную информацию
о данных.
Зависимость осталась, но она стала как-то мягче, потому что структуры данных,
используемые при записи и чтении, здесь уже ближе к их фомату внутри программы.


## 3. Зависимость зависимости
В школе при подготовке к олимпиаде по программированию было одно задание,
где наши программы должны были соревноваться друг с другом в какой-то игре.
Многие простои использовали генерацию псевдослучайных чисел, и я тоже.
Но только мне пришло в голову в начале своей программы перезагружать генератор,
используя счётчик тактов процессора.

Из-за особенностей организации автоматического тестирования, генератор
псевдослучайных чисел был ОБЩИМ для обеих программ, участвующих в поединке.
При соревновании с моей программой все остальные получали минимальные балы
(по сравнению с поединками с другими соперниками).
Победы мне это, правда, не принесло, потому что моя программа получала
ещё меньше по той же причине :)

Разбираться с этой зависимостью никто не стал.
Организаторы решили, что это не баг, а фича.


## 4. Зависимость краша
В начале нулевых я экспериментировал с динамической памятью в Delphi
на Windows Me.
Примерно половина запусков мих программ в то время вызывала крах ОС и BSOD.

В следующих версиях Windows виртуальная память стала ещё виртуальнее,
и работоспособность ОС уже не зависела от особенностей каждого приложения.


## 5. Зависимость перебрасывания
Никогда не любил в учебных примерах штуки типа
```C
if (OPENGL_EXTENSION_FOO == TRUE) {
    ...
} else {
    // А то что?
}
```
```Java
if (ANDROID_VERSION > XXX) {
    ...
} else {
    // И?
}
```
Лучше уж просто в требованиях жёстко прописать зависимость от конкретного
интерфейса.
Это, конечно, если речь не идёт о чём-то очень важном, где действительно
надо хоть тушкой хоть чучелом продолжать выполнение.

Недавно коллеги рассказали случай.
В диагностическом центре зависла касса, и пациенты 4 часа ждали своего счастья,
пока в этой очереди нашёлся профессиональный бухгалтер, который научил
местных сотрудников как проводить оплату вручную.

Вот здесь бы перебрасывание точно не повредило.
Можно же наклеить на кассу инструкции по ручному проведению платежей,
примерно как на запасном выходе в транспорте.


## 6. Зависимость инверсии
Очень похоже на "зависимость расшаренного формата", только здесь не данные,
а интерфейсы.

Никогда не приходило в голову с этим бороться.
Наоборот, в книжках прочитал, что это хорошо.
Сделал вывод, что интерфейс не должен быть слишком абстрактным,
чтобы сохранить возможность статической проверки.


## 7. Зависимость зацикливания
Для меня это прежде всего про callback-процедуры.
Получается, что одна из частей программы может быть запущена
сторонней библиотекой в любой момент, и если при этом используется
общее состояние (глобальные переменные, например), то на это больно смотреть.
Модуль зависит сам от себя, но через посредника, неконтролируемым образом.
Это распространено в API ОС, графических библиотеках, библиотеках для
численных расчётов и т.п.

Спасение - использование чистых функций и/или строгое отделение состояний
основной и callback частей программы.


## 8. Зависимость высшего порядка
В самой новой моей расчётной программе до недавнего времени как раз была
возможность наследования от класса `Axis`, который помогал идентифицировать
оси тензоров и использовался в качестве ключа словарей внутри нескольких
базовых модулей.

Про проблему с возможным переопределением хэша я тогда не думал,
но возможность наследования убрал по другим причинам.


## 9. Зависимость большинства
В пункте 3. ведь никто не стал заморачиваться собственным генератором
псевдослучайных чисел
(хотя математическая подготовка минимум половины участников
это вполне позволяла).
ВСЕ предполагали, что их программа будет выполняться в изолированной среде,
что никто не сломает функцию `random`.
Я тоже предполагал... и ещё функцию сломал.

Хорошим тоном (особенно при научных расчётах) является использования отдельных
генераторов псеводслучайных чисел под каждую логически независимую
их последовательность.
В некоторых библиотеках в принципе нет никаких глобальных генераторов.
Просто представим себе такое в DLL, используемой сразу несколькими приложениями.
А вдруг, это расчёт ядерной реакции методом Монте-Карло.


## Резюме
Узнал несколько новый и совсем неочевидных типов зависимости.

Особенно меня впечатлила зависимость высшего порядка.
Слишком много свободы при наследовании плюс нарушение наследниками LSP
из SOLID может привести к самым неожиданным последствиям.
Так что важно не давать пользовательскому коду "проникать" в библиотеку,
например, портить работу хэш-таблиц.

Вообще, зависимость может быть через что угодно.
Даже через железо и ОС, если, например,
программы выполняются на одном компьютере, и кто-то из них занял всю память
(вот захотелось комплексную матрицу 20 на 20 тысяч во имя высокой науки).
На домашнем/рабочем компьютере это, по моему опыту, файл подкачки
и "конец истории" - проще нажать Reset,
чем полчаса целиться неживой мышью в крестик.
На суперкомпьютерах и всяких хостингах с этой проблемой ОС вполне справляется.

Вывод такой: при разработке нужно знать про разные виды зависимостей,
видеть их в своей программе и стремиться предотвратить возможные проблемы.
