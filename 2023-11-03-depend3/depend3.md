# Избавляемся от зависимости от зависимостей - 3

## 1. Зависимость фреймворка
Для расчётов на суперкомпьютере мне снова понадобится C++,
и библиотека GSL, или другая, или несколько.
Фактически, нужны не сами библиотеки, а некоторые численные алгоритмы,
для которых я, конечно, буду делать обёртки.
То есть, от фреймворка будет зависеть только внутренняя реализация этих обёрток.
Поскольку их спецификация будет фиксированной и не зависящей от внених библиотек,
Другие свойства программы зависеть от библиотек тоже не будут.


## 2. Зависимость расшаренного формата
Сколько форматов хранения данных, столько и спецификаций интерфейса
сериализаторов и десериализаторов.
Сформулирую свою спецификацию, которая мне удобнее, и буду делать обёртки
для сторонних библиотек.
Так зависимость будет локализована:
изменение формата будет причиной изменений только сериализатора/десериализатора.


## 3. Зависимость зависимости
Оказывается, в Python, если у функции значение аргумента по умолчанию -
это ассоциативный массив,
то это один и тот же ассоциативный массив при каждом вызове функции.
Если функция его изменяет, то он изменится и для всех других вызовов.
Долго я ошибку в программе искал, удивительные результаты она выдавала.
Лекарство тут простое: не зачем функции менять свои аргументы.
После таких сессий отладки всё больше начинаешь проникаться принципами
функционального программирования, особенно очевидна польза
неизменяемых значений.


## 4. Зависимость краша
В программах для научных расчётов устойчивость к сбоям не требуется.
Если что-то сломалось, то правильный результат всё равно не получим.
Так что просто не будем учитывать сбои в спецификации явно.

Отдельно отмечу, что это не относится к ситуациям, когда численный алгоритм
не сошёлся к решению и нужно корректировать параметры.
Это не сбой, а рабочий момент.


## 5. Зависимость перебрасывания
В принципе, в планах было освоить расчёты на видекарте и перебрасывать
всё на расчёт на процессоре, если видеокарта такое не поддерживает.
Тут важно локализовать зависимость внутри обёрток к численным алгоритмам.
Тогда зависимость от конкретного устройства в большей части программы будет
ненаблюдаема.


## 6. Зависимость инверсии
Каждая функция имеет интерфейс, от которого зависит и реализация,
и вызывающий код.
В Python в качестве аргументов можно передать что угодно, и тут большое поле
для ошибок.
Я использую статический тайп-чекер в "строгом" режиме,
так что случайно нарушить соглашение об интерфейсе очень непросто.
С C++ это будет ещё сложнее из-за статической проверки типов компилятором.


## 7. Зависимость зацикливания
При численном решении дифуров в солвер передаётся функция,
которая затем вызывается непредсказуемым образом.
Означает ли это, что моя программа зависит сама от себя?
Нет, если функция чистая.
Вызов такой функции не меняет никаких наблюдаемых состояний в программе.
Это её независимая часть, так что зацикливание зависимостей не возникает.


## 8. Зависимость высшего порядка
Есть модуль для работы с многомерными массивами,
который использует концепцию осей по аналогии с NumPy,
только тут каждая ось - это отдельная сущность.
Ещё на прошлой неделе оси с одинаковыми именами считались равными,
но это создавало проблемы.
Для некоторых расчётов нужно создавать дополнительные оси,
которые не должны совпадать с осями исходных данных.
Получается, что функция обычно работает нормально, но падает,
если во входных данных будут оси с определённым именем,
которое снаружи функции не видно.

Можно, конечно, было выделить временным осям определённое пространство имён,
или придумать механизм генерации безопасных имён осей.
Я сделал проще.
Оси равны, только если это одна и та же сущность.
Тогда оси, созданные внутри функции никак не помешают тем, которые передаются
извне.


## 9. Зависимость большинства
Код для АЭС писать не приходилось, но были случаи, когда мы с коллегами
писали программы независимо и с помощью разных инструментов,
а потом сверяли результаты перед публикацией.
В нашей задаче результат детерминированный, так что расхождения были поводом
для проверки программ.
Так и получалось, что опубликованный результат не зависел полностью
от каждой из двух расчётных программ.
Он зависел от их консенсуса.


## Резюме

### 1. Вывод по изучению материла
Не так уж всё и страшно оказалось с зависимостями.
Можно подумать, что всё зависит от всего, так как в условиях полной свободы
можно придумать способ уронить систему из любого модуля.
Тогда и делать ничего не надо в плане улучшения зависимостей - бесполезно.

Когда есть ограничения (пространство допустимых изменений), и мы выделяем
конкретные свойства, то уже можно как-то конструктивно работать.
Можно уменьшать количество свойств, которые подвержены зависимостям,
с помощью всяких обёрток и других абстракций.
Можно убирать зависимости, ограничивая область допустимых изменений,
и не всегда с помощью ругачего тимлида, иногда это можно сделать на уровне
системы типов.
Можно разбивать зависимость на части с помощью перебрасывания и дублирования.
Немного парадоксально, что в последнем случае усложнение системы делает её
более надёжной.


### 2. Вывод по практике
После этого задания понял, почему мне так некомфортно работать с
сериализацией/десериализацией.
Это из-за того, что в библиотеках нет таких интерфейсов.
Точнее, они есть, но они зависят от конкретного формата хранения данных,
например, разделение вложенных узлов и атрибутов, которое есть в XML и HDF5,
но отсутствует в JSON.
Теперь созрело решение выработать свой интерфейс для внешнего хранения данных
и добавить в программу соответствующий модуль.

Фреймворки никогда мне не нравились по той же причине.
Большинство из них спроектировано так, что наша программа выглядит
как плагин.
Очень сложно локализовать такую зависимость.
Похоже, что даже NumPy я постепенно буду в своей программе локализовывать,
если окончательный переход на связку DSL-C++ не случится раньше.

Ещё в очередной раз убедился в пользе элементов
функционального программирования.
Неизменяемые значения и чистые функции помогают избегать
очень многих зависимостей.
